---
title: 构造过程抽象
date: 2024-6-05 17:34:00
tags: [计算机基础,读书笔记]
category: 计算机基础
---

### 前言

如果想要设计一个程序，需要考虑哪些元素？是数据的录入？还是数据的查询？亦或是操作数据的过程？还是应该考虑使用哪种编程范形？

编程范式在如今不是一个新的话题，初学者中在学习任何一门高级编程语言时都会被“面向对象”，“函数式编程”，“过程式编程”等风格影响，以构建出来不同风格的程序。编程范形会告诉初学者应该禁止使用哪些技术，同时允许哪些。当然，对于初学者来说可能并不会意识到自己被编程范式所影响，他们可能对此一无所知。那些晦涩的概念很容易让人失去兴趣，转而被高级编程语言本身的细节所吸引，而忽视掉抽象的这一核心思想。

不同高级编程语言会有不同的优势，比如C语言的强大灵活，Go的并发设计，Rust的安全等。作者本人初次接触高级编程语言也会沉迷它的细节，在接触到更多的编程语言后也会赞叹某一种语言的设计的精巧，回过头再来思考这些语言，它们是否存在某些共性？

无论哪一种编程范式都会包含三个要素：**基本表达形式**用来表示程序构建的最小单位；**组合方法**用来将简单元素构建为复合元素；**抽象方法**：将复合对象命令，将它们作为一个单位来操作。

本系列文章将会逐一解析这三个要素，并参考《计算机程序的构造和解释》一书从"面向过程"的角度来解释它们背后表达出来的思想。



### 构造过程抽象

如果说程序的本质就是计算，可能会让人觉得过于片面和含糊不清，计算只是程序能力的一部分。从底层说起它包含更加复杂的定义，比如指令集，数据结构和算法，逻辑和控制等。现如今任何一种高级编程语言都会包含：表达数字和算术运算的方式；提供将多种基础元素组合在一起的复合元素方法；定义一种抽象方式来概括某一系列复合元素。

SICP 第一章开篇，作者提到："Computer programs are a means of communication. We use them to tell a computer what to do, but more fundamentally, we use them to communicate ideas about processes."

> 计算机程序是一种沟通的手段。我们用它们来告诉计算机应该做什么，但是根本上，我们用它来表达关于'过程'的思想。

从工程实践的角度来看，“程序是写给其他程序员看的，只是恰好能被计算机执行”则是另一种观点的表达，但是它们都表示出一种共同的理念：程序是表达开发者解决某一领域问题的解题思路。

那么过程应该如何被构造？

通常在高级编程语言中，工程师可以通过“函数”来描述一系列计算过程，函数可以直接视为一个过程吗？函数是描述一件事的特征，而过程是描述如何去做这件事。在不同领域中关心的重点是不同的，在数学领域中人们关心的是说明性的描述——这个函数描述的是什么？在计算机领域，人们通常关心行动性的描述——这个函数是怎么做的？





#### 程序的元素







### 基本表达形式

```go
func Sum(a,b int) int {
  reture a + b
}
```

将程序仅仅定位为计算也许过于武断，在谈及计算机可以帮你重复计算，解决很多重复的通用性问题应该没人反对。

在程序设计中，开发者可以依靠定义[函数]来描述一系列计算过程，可以简略将它认为是一个**过程定义**的方法，也是上述提到的[复合过程]。

函数可以视为一个过程吗？函数是描述一个件事的特征，而过程是描述如何去做这件事。它们之间存在一个普遍性差异，这个差异可以被形容成，说明性与行动性知识之间的差异。

在数学中，人们通常关心的是说明性的描述——即指它描述的是什么？

而在计算机领域，人们则通常关心行动性的描述——即某个函数是怎么做的。

当然这里只是在形容它们的差异性，不代表它们之间就没有某种联系。



使用递归，可以自己构建出[迭代器]，但递归真的是个好主意吗？从直观的角度来判断，无法推断出它的过程。一个机遇过程自身来定义它的想法很可能会令人感到不安，开发者会觉得它不够清晰。

过程抽象是什么呢？

函数很有可能是一个过程抽象，输出什么值然后输出什么值，根本不用关心这个计算过程是如何得到的，因此可以将函数作为一个黑箱。一个过程定义应该能隐藏一些细节，这会让使用者不用自己去写这些过程。



> 函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异。在数学中，人们通常关心的是说明下的描述，比如描述一个公式是什么？
>
> 而在计算机科学中，人们通常关心行动性的描述，这指的是如何实现。



对表达式的求值规则可以描述为一个简单的通用规则喝一组针对不多的特殊形式的专门规则。通用规则和特殊规则。







**抽象方法**

作者本人在最初学习C#时一度混淆虚方法(virtual)和抽象方法的(abstract)的区别，但在Lisp中声明一个变量可能就是最简单的抽象方法：

> define a 1

当我们解析一个程序时，你会发现无论多复杂的程序，都是从简单的对象作为基础对象而组成。解释器的存在让程序的构造过程变得非常方便，可以通过一系列交互式的动作，逐步创建出一系列对象的关联关系。

递归可以看作一种处理层次结构的强有力的技术，在处理"树"形结构时候非常适合。



数学函数和计算机的过程之间有一个重要差异：过程必须是有效可行的。函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异的一个具体反映。在数学中，通常关心的是说明性的描述(它是什么)，但是在计算机科学中，则关心行动性的描述(如何做)。

解释器会做的足够复杂，程序员描述了需要“做什么”的知识后，解释器就能自动产生出“怎么做”的知识。

一个过程定义能隐藏一些细节。过程的使用可以不用重复写这些过程。

过程的形式参数在过程体里扮演着一种非常特殊的角色，形参的具体名字不重要。如果在一个完整的过程定义里将某个约束变量统一换名，这一过程定义的意义将不会有任何改变。如果一个变量不是被约束的，可以把它称为“自由的”。一个名字的定义被约束于的那一集表达式称为这个名字的作用域。在一个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程的体作为它们的作用域。

> 能看清楚所考虑的动作的后果的能力，对于成为程序设计专家是至关重要的。这种能力在所有综合性的创造活动的作用是一样的。在程序设计中，需要会计算过程中各种动作的进行情况做出规划，用一个程序控制这一过程的进展。所以需要学会看清不同种类的过程会产生什么样的计算过程。

一个过程，描述的是一个计算过程的局部演化方式，描述计算过程中每个步骤是如何基于前面的步骤建立起来的。



不同的计算过程在消耗计算资源的速率上可能存在巨大差异，描述这种差异的一种方式是用增长的阶的记法，以便理解在输入变大时，某一计算过程所需资源的粗略度量情况。

> 相同的数学定义，用不同的过程结构实现，效率却差距巨大。





尾调用：某个函数的最后一步就是调用另外一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即可。

```go
func f(x){
  return g(x)
}



// 但是这种不属于尾调用，因为调用后还存在操作
func f(x){
  return g(x) + 1;
}

// 属于尾调用
func f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

尾调用优化：尾调用之所以与其他调用不同，在于它的特殊的调用位置。

函数调用会在内存形成一个“调用记录”，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/调用栈)（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置，内部变量等信息都不会再用到了，只要直接用内层函数等调用记录，取代外层函数等调用记录就好了。这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。



回到函数编程中的尾递归：函数调用自身称为递归。如果尾调用自身便为称为尾递归。

递归非常耗费内存，因为需要同时保存成千上万个调用记录，很容易发生“栈溢出”。但是对于尾递归来说，由于只存在一个调用记录，所以永远不会发生“栈溢出”错误。

在函数式编程中，有一个概念叫做"柯里化"，意思是将多参数的函数转换成单参数的形式。



### 高阶函数抽象

过程也就是一类抽象，它们描述了一些对于数的复合操作，但是又不依赖于特定的数。**人们对功能强大的程序设计语言有一个必然要求，就是能为公共的模式命名，建立抽象，然后直接在抽象的层次上工作。过程提供了这种能力。**

如果将过程限制为只能以数作为参数，那也会很严重限制建立抽象的能力。

能操作过程的过程称为**高阶过程**，当多个过程共享同一种公共的基础模式。它们实际上很大一部分是共同的，只在所用的过程名字上不一样，那么说明实际上存在一种很有用的抽象。

Lamabda 匿名函数，在多种编程语言中都能看到它不同的实现，这些实现略有差别，但它的重要用途是：

通过引入Lambda来完成一类特殊的描述，这种特殊形式能创建出所需要的过程。

Lambda 另一个应用场景是创建局部变量。在一个过程中，除了那些已经成为局部变量中，还需要另外一些局部变量。这代表解释器需要识别，哪些是“函数”哪些是“数据”，不能随便把“数据”当作函数去使用。

复合过程作为一种将若干操作的模式抽象出来的机制，使其描述的计算不再依赖于所涉及的特定的数值。

高阶过程其实也是一类方法，是用于表述计算的一般性过程，和它涉及的特定函数无关。

> 将过程作为参数传递，能显著增强我们的程序设计语言的表达能力,通过创建另一种其返回本身也是过程的过程，还可以得到进一步的表达能力。



```go
// 计算给定范围内的整数的立方只和
func sumCubes(a, b int) int {
	if a > b {
		return 0
	}
	return cube(a) + sumCubes(a+1, b)
}

func piSum(a, b int) int {
	if a > b {
		return 0
	}
	return ((a+2)*a)/1.0 + piSum(a+4, b)
}

func cube(a int) int {
	return a * a * a
}
```

复合过程是一种至关重要的抽象机制，它可以让我们能将一般性的计算方法，用着一程序设计语言里的元素明确描述。高阶函数能如何去操作这些一般性的方法，以建立起进一步的抽象。如何根据工作中的情况，选择合适的抽象层次。能基于这种抽象去思考确实是最重要的，高阶过程的重要性在于使我们能显式地用程序设计语言的要素去描述这些抽象，能像操作其他设计元素一样去操作它们。



### 学习资料



https://people.eecs.berkeley.edu/~bh/sicp.html

https://www.ruanyifeng.com/blog/2015/04/tail-call.html

《计算机程序的构造和解释》













