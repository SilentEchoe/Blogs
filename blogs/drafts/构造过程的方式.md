---
title: 构造过程抽象
date: 2024-6-05 17:34:00
tags: [计算机基础,读书笔记]
category: 计算机基础
---

### 前言

如果想要设计一个程序，需要考虑哪些元素？是数据的录入？还是数据的查询？亦或是操作数据的过程？还是应该考虑使用哪种编程范形？

编程范式在如今不是一个新的话题，初学者中在学习任何一门高级编程语言时都会被“面向对象”，“函数式编程”，“过程式编程”等风格影响，以构建出来不同风格的程序。编程范形会告诉初学者应该禁止使用哪些技术，同时允许哪些。当然，对于初学者来说可能并不会意识到自己被编程范式所影响，他们可能对此一无所知。那些晦涩的概念很容易让人失去兴趣，转而被高级编程语言本身的细节所吸引，而忽视掉抽象的这一核心思想。

不同高级编程语言会有不同的优势，比如C语言的强大灵活，Go的并发设计，Rust的安全等。作者本人初次接触高级编程语言也会沉迷它的细节，在接触到更多的编程语言后也会赞叹某一种语言的设计的精巧，回过头再来思考这些语言，它们是否存在某些共性？

无论哪一种编程范式都会包含三个要素：**基本表达形式**用来表示程序构建的最小单位；**组合方法**用来将简单元素构建为复合元素；**抽象方法**：将复合对象命令，将它们作为一个单位来操作。

本系列文章将会逐一解析这三个要素，并参考《计算机程序的构造和解释》一书从"面向过程"的角度来解释它们背后表达出来的思想。



### 构造过程抽象

如果说程序的本质就是计算，可能会让人觉得过于片面和含糊不清，计算只是程序能力的一部分。从底层说起它包含更加复杂的定义，比如指令集，数据结构和算法，逻辑和控制等。现如今任何一种高级编程语言都会包含：表达数字和算术运算的方式；提供将多种基础元素组合在一起的复合元素方法；定义一种抽象方式来概括某一系列复合元素。

SICP 第一章开篇，作者提到："Computer programs are a means of communication. We use them to tell a computer what to do, but more fundamentally, we use them to communicate ideas about processes."

> 计算机程序是一种沟通的手段。我们用它们来告诉计算机应该做什么，但是根本上，我们用它来表达关于'过程'的思想。

从工程实践的角度来看，“程序是写给其他程序员看的，只是恰好能被计算机执行”则是另一种观点的表达，但是它们都表示出一种共同的理念：程序是表达开发者解决某一领域问题的解题思路。

那么过程应该如何被构造？

最基础的就是表达式和运算符，数字的表达式可以和各种运算符组合起来，形成一个运算符组合式，比如：

```go
(2 * 5) / (3-1)
```

为了更贴近我们的生活，编程语言会提供括号来做分组计算，如果抛开括号，语言也会遵循常规的规则：乘除运算符号会优先于加减运算符，并且这些都是**左结合。**

> 运算符优先级相同的情况下，从左边向右边计算，就是左结合。

在面对复杂的表达式`3 * 12 * (25/5) + 83 / 25 * 10`，依托于解释器的强大可以很快得出结论：213.2，但如同上述中我们提到的，程序构建的代码是要写给其他程序员看的，我们面对这样复杂的表达式难以清晰快速进行计算。

当用一个带分支的结点表示每一个最基础的组合式，用树形来看待求值过程，可以想象运算结果从下往上传递，最终构建出一颗倒立的“树”:

```
         [213.2]
         /     \
      [180]    [33.2]
     /   \     /     \
  [36]   [5]  [3.32] [10]
  /  \   / \   / \
 3  12  25  5 83  25
```

高级编程语言都会提供一些抽象的手段，用一个变量来代表一个基础的数字或字母，亦或一段文本。

```go
const a = 3.1415926
b := a * 2
> 6.2831852
```

解释器会把`3.1415926`与`常量a`关联起来，在后续的代码中可以通过使用该常量来代替它的真实值。这是为了在构建复杂的计算过程中屏蔽掉部分的细节，如果每次要使用`3.1415926`就必须记住整串数字，在庞杂的代码中复杂度会不断提升。解释器通过这种方式来降低视觉上的复杂性，同时让工程师逐渐建立对象关联，从而一步一步构建更加复杂的计算过程。

而**函数**则是更强大的抽象技术，通过函数可以自定义一个名称，并将其**关联**一组复合操作，像使用常量一样来使用这组复合操作:

```go
func main(){
	fmt.Println(square(3))
}

func square(x int) int{
	return x * x
}

> 9
```

`func`关键字是表达声明一个**函数**，square 则是函数的名称，意味着 square 这个函数名会与 `x * x` 这个运算过程相关联，x 被称为 parameters(形式参数)，它们被用在函数体中，相当于声明一个变量，但它的**作用域**仅限于这个函数中。`return`关键字用于返回函数的计算结果，这里只是简单返回一个表达式的计算结果。

我们解析一个程序时会发现无论多复杂的程序，都是由基础对象组合构建出复杂对象，基础函数构建出复杂函数。如果把函数当作一个过程定义，那么它可以能隐藏一些运算过程，也就是隐藏一些细节，更通俗的说法是把函数当作一个黑盒，其他工程师只用关注这个函数的“作用”，即输入什么然后得到什么。依靠函数名来重复使用这些函数，而不用重复拷贝这些运算过程，这点极大地提高了便利性，也能直接使用其他函数或自身来构建出更复杂的函数，最后一步一步构建出应用。

> 数学函数和计算机函数的明显区别在于，说明性知识与行动性知识之间的差异。数学中人们更关心"是什么"，在计算中人们则更关心"怎么做"。而且计算机函数必须是有效可行的。

```go
package main

import (
	"fmt"
	"math"
)

const tolerance = 0.00001

// 判断两个浮点数是否接近
func isGoodEnough(guess, x float64) bool {
	return math.Abs(guess*guess-x) < tolerance
}

// 改进猜测
func improve(guess, x float64) float64 {
	return (guess + x/guess) / 2
}

// 递归尝试求平方根
func sqrtIter(guess, x float64) float64 {
	if isGoodEnough(guess, x) {
		return guess
	}
	return sqrtIter(improve(guess, x), x)
}

// 外部调用接口
func sqrt(x float64) float64 {
	return sqrtIter(1.0, x) // 初始猜测为 1.0
}

func main() {
	fmt.Println("sqrt(9) =", sqrt(9))
	fmt.Println("sqrt(2) =", sqrt(2))
	fmt.Println("sqrt(0.01) =", sqrt(0.01))
}
```

`sqrt`函数作为SICP中第一个手工定义的函数实现计算过程的例子，它展现了一部分函数的特性：通过调用其他函数来构建出一个复合函数；将`sqrtIter`函数当作一个黑盒使用；将一个计算过程分解成若干个子问题，还展示了如何不使用迭代器来实现迭代，然后通过简单的独立函数共同计算来解决问题;

> 一个函数就是一个计算过程的**局部演化**的模式，它描述了这个过程中每个步骤如何在前面步骤的基础上进行。





### 递归

当提到递归的时候，指的是一个函数直接或间接引用了该函数本身。阶乘函数是最简单利用"递归"这一方法来计算`n*(n-1)`的方式

```go
func main() {
	fmt.Println(factorial(4))
}

//递归
func factorial(n int) int {
	if n == 1 {
		return 1
	}
	return n * factorial(n-1)
}

//循环
func factorial(n int) int {
	result := 1
	for i := 2; i <= n; i++ {
		result *= i
	}
	return result
}
```

上述代码中，`factorial`函数有两种写法，一种是使用递归，第二种是使用`for`关键字循环来计算结果。在各种教程中**递归**是一种强表达力的方式，它在解决树，图，分治算法等场景非常简洁优雅，但是它会带来性能和栈空间的开销，相比之下循环更适合性能敏感的代码。

当调用一个函数时，程序会在**调用栈**为它分配一个"栈帧"，然后保存**函数的参数，局部变量，返回地址**。递归调用时每一层都会新增一个栈帧，这意味着在内存中会存在4个栈帧:

```
factorial(4)
 → factorial(3)
   → factorial(2)
     → factorial(1)
```

在Go语言中`goroutine`虽然可以动态扩容，但是它也是存在限制的，最大可达到1G的栈大小，不可能无限递归下去。相比之下循环则不会增加栈帧，永远只固定那点内存。当递归执行时每次都需要压栈和出栈，循环在同一个作用域中修改局部变量，减少了调用和恢复的过程。

> 递归是用空间换简洁性，循环是用变量控制流程。递归要谨慎使用，特别要注意结束递归的条件。



#### 树形递归

斐波那契数列的计算如果使用树型递归来表示，这一计算过程像是一棵树：分支在每一层都分裂成两个不同的分支，层层递进。

```go
//树形递归
func fib(a, b, count int) int {
	if count == 0 {
		return b
	}
	return fib(a+b, a, count-1)
}

//线性迭代
func fact(n int) int {
	if n == 0 {
		return 1
	}
	return n * fact(n-1)
}
```

线性迭代和树形递归会产生巨大的差异……这里的差异主要在性能方面，无论是空间还是时间上树形递归都远不如线性迭代。

虽然树形递归的计算过程可能非常低效，但是它很容易描述和理解。它把一个大的问题分解成了多个小的问题，这种思维方式天然契合树状结构，也进一步可视化复杂程度是如何产生的。

```shell
Fib(5)
├─ Fib(4)
│  ├─ Fib(3)
│  │  ├─ Fib(2)
│  │  │  ├─ Fib(1) = 1
│  │  │  └─ Fib(0) = 0
│  │  └─ Fib(1) = 1
│  └─ Fib(2)
│     ├─ Fib(1) = 1
│     └─ Fib(0) = 0
└─ Fib(3)
   ├─ Fib(2)
   │  ├─ Fib(1) = 1
   │  └─ Fib(0) = 0
   └─ Fib(1) = 1
```

每一次计算都会分裂成两个子计算，最终形成树。其中Fib(3)计算了两次，Fib(2)计算了三次。随着n不断增大，树的节点快速膨胀，重复计算的节点增多，导致树形递归效率低下。



### 增长的阶和求幂

SICP中“增长的阶”其实就是**渐进复杂度(Order of Growth)**，它用来**衡量一个算法在输入规模不断增大时，运行时间或占用空间会如何变化**。重点是**趋势**，而不是精确的数值，所以一般用**数量级**来概括它。

当数据规模很小时，不同算法之间的差异无法直观呈现出来。但是在处理大量数据时，效率差异就会被放大，这时就必须要考虑它的增长方式。可能部分读者在接触算法时了解过**大 O 表示法（Big-O Notation）**，这里要澄清一下这两者之间的关系。

渐进复杂度是一个更加宽泛的概念，SICP中提到的线性阶、对数阶、指数阶是它的分类。而大O表示法是用来描述前者**数学符号工具**，比如用O(log n)这样的符号来表示二分查找。

以**求幂（b^n）**为例：

```go
// Expt 线性递归实现 b^n
func Expt(b, n int) int {
	if n == 0 {
		return 1
	}
	return b * Expt(b, n-1)
}


// FastExpt 快速幂实现 b^n
func FastExpt(b, n int) int {
	if n == 0 {
		return 1
	}
	if n%2 == 0 { 
		half := FastExpt(b, n/2)
		return half * half
	}
	return b * FastExpt(b, n-1)
}
```

程序表面显出的数据结构和运行的本质代码可能不一样，使用线形递归看起来优雅又直观，但是增长的阶是**指数级**，在大规模输入的情况下会很缓慢。`FastExpt`虽然逻辑相对复杂，但是增长的阶只有**对数级**。

这其中的区别在于`b^5 = b * b * b * b * b`每次都把n减1，直为0，调用次数由n来决定，所以它表示为`O(n)`。

当使用快速幂实现时，先把指数按二进制拆解，通过不断平方法和乘法实现。b的五次方会变成：`b^5 = b^4 * b = b ^ (2^2) * b`，这种方式和二分法的思想是一样的，通过每次把问题规模折半，逐步缩小范围，直到计算出答案。它表示为`O(log n)`。

```shell
FastExpt(2, 5)
= 2 * FastExpt(2, 4)
= 2 * (FastExpt(2, 2) ^ 2)
= 2 * ((FastExpt(2, 1)) ^ 2)
= 2 * ((2 * FastExpt(2, 0)) ^ 2)
= 2 * (2 ^ 2)
= 2 * 4
= 32
```





### 高阶函数抽象











使用递归，可以自己构建出[迭代器]，但递归真的是个好主意吗？从直观的角度来判断，无法推断出它的过程。一个机遇过程自身来定义它的想法很可能会令人感到不安，开发者会觉得它不够清晰。





对表达式的求值规则可以描述为一个简单的通用规则喝一组针对不多的特殊形式的专门规则。通用规则和特殊规则。







**抽象方法**

作者本人在最初学习C#时一度混淆虚方法(virtual)和抽象方法的(abstract)的区别，但在Lisp中声明一个变量可能就是最简单的抽象方法：

> define a 1

当我们解析一个程序时，你会发现无论多复杂的程序，都是从简单的对象作为基础对象而组成。解释器的存在让程序的构造过程变得非常方便，可以通过一系列交互式的动作，逐步创建出一系列对象的关联关系。

递归可以看作一种处理层次结构的强有力的技术，在处理"树"形结构时候非常适合。



数学函数和计算机的过程之间有一个重要差异：过程必须是有效可行的。函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异的一个具体反映。在数学中，通常关心的是说明性的描述(它是什么)，但是在计算机科学中，则关心行动性的描述(如何做)。

解释器会做的足够复杂，程序员描述了需要“做什么”的知识后，解释器就能自动产生出“怎么做”的知识。

一个过程定义能隐藏一些细节。过程的使用可以不用重复写这些过程。

过程的形式参数在过程体里扮演着一种非常特殊的角色，形参的具体名字不重要。如果在一个完整的过程定义里将某个约束变量统一换名，这一过程定义的意义将不会有任何改变。如果一个变量不是被约束的，可以把它称为“自由的”。一个名字的定义被约束于的那一集表达式称为这个名字的作用域。在一个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程的体作为它们的作用域。

> 能看清楚所考虑的动作的后果的能力，对于成为程序设计专家是至关重要的。这种能力在所有综合性的创造活动的作用是一样的。在程序设计中，需要会计算过程中各种动作的进行情况做出规划，用一个程序控制这一过程的进展。所以需要学会看清不同种类的过程会产生什么样的计算过程。

一个过程，描述的是一个计算过程的局部演化方式，描述计算过程中每个步骤是如何基于前面的步骤建立起来的。



不同的计算过程在消耗计算资源的速率上可能存在巨大差异，描述这种差异的一种方式是用增长的阶的记法，以便理解在输入变大时，某一计算过程所需资源的粗略度量情况。

> 相同的数学定义，用不同的过程结构实现，效率却差距巨大。





尾调用：某个函数的最后一步就是调用另外一个函数。尾调用不一定出现在函数尾部，只要是最后一步操作即可。

```go
func f(x){
  return g(x)
}



// 但是这种不属于尾调用，因为调用后还存在操作
func f(x){
  return g(x) + 1;
}

// 属于尾调用
func f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
```

尾调用优化：尾调用之所以与其他调用不同，在于它的特殊的调用位置。

函数调用会在内存形成一个“调用记录”，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/调用栈)（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置，内部变量等信息都不会再用到了，只要直接用内层函数等调用记录，取代外层函数等调用记录就好了。这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。



回到函数编程中的尾递归：函数调用自身称为递归。如果尾调用自身便为称为尾递归。

递归非常耗费内存，因为需要同时保存成千上万个调用记录，很容易发生“栈溢出”。但是对于尾递归来说，由于只存在一个调用记录，所以永远不会发生“栈溢出”错误。

在函数式编程中，有一个概念叫做"柯里化"，意思是将多参数的函数转换成单参数的形式。



### 高阶函数抽象

过程也就是一类抽象，它们描述了一些对于数的复合操作，但是又不依赖于特定的数。**人们对功能强大的程序设计语言有一个必然要求，就是能为公共的模式命名，建立抽象，然后直接在抽象的层次上工作。过程提供了这种能力。**

如果将过程限制为只能以数作为参数，那也会很严重限制建立抽象的能力。

能操作过程的过程称为**高阶过程**，当多个过程共享同一种公共的基础模式。它们实际上很大一部分是共同的，只在所用的过程名字上不一样，那么说明实际上存在一种很有用的抽象。

Lamabda 匿名函数，在多种编程语言中都能看到它不同的实现，这些实现略有差别，但它的重要用途是：

通过引入Lambda来完成一类特殊的描述，这种特殊形式能创建出所需要的过程。

Lambda 另一个应用场景是创建局部变量。在一个过程中，除了那些已经成为局部变量中，还需要另外一些局部变量。这代表解释器需要识别，哪些是“函数”哪些是“数据”，不能随便把“数据”当作函数去使用。

复合过程作为一种将若干操作的模式抽象出来的机制，使其描述的计算不再依赖于所涉及的特定的数值。

高阶过程其实也是一类方法，是用于表述计算的一般性过程，和它涉及的特定函数无关。

> 将过程作为参数传递，能显著增强我们的程序设计语言的表达能力,通过创建另一种其返回本身也是过程的过程，还可以得到进一步的表达能力。



```go
// 计算给定范围内的整数的立方只和
func sumCubes(a, b int) int {
	if a > b {
		return 0
	}
	return cube(a) + sumCubes(a+1, b)
}

func piSum(a, b int) int {
	if a > b {
		return 0
	}
	return ((a+2)*a)/1.0 + piSum(a+4, b)
}

func cube(a int) int {
	return a * a * a
}
```

复合过程是一种至关重要的抽象机制，它可以让我们能将一般性的计算方法，用着一程序设计语言里的元素明确描述。高阶函数能如何去操作这些一般性的方法，以建立起进一步的抽象。如何根据工作中的情况，选择合适的抽象层次。能基于这种抽象去思考确实是最重要的，高阶过程的重要性在于使我们能显式地用程序设计语言的要素去描述这些抽象，能像操作其他设计元素一样去操作它们。



### 学习资料

https://people.eecs.berkeley.edu/~bh/sicp.html

https://www.ruanyifeng.com/blog/2015/04/tail-call.html

《计算机程序的构造和解释》













