---
title: SICP|模块化，对象和状态
date: 2025-10-29 13:54:00
tags: [计算机基础,读书笔记]
category: 计算机基础
---

前两章[构造数据抽象](https://silentechoe.github.io/2025/10/26/%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/)和[构造过程抽象](https://silentechoe.github.io/2025/09/28/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/)讲述了如何组合基础函数和基础数据，这些很好展现了**抽象**是如何解决大型系统的复杂性问题。抽象是一个强大的工具，它可以帮助我们解决构建大型系统中的复杂度的问题。此外还需要一些设计策略，因为它能帮助我们使其**模块化**。

> 所谓模块化就是能让系统“自然地”分割成一些具有内聚力的，可以独立开发和维护的部分，而高内聚和低耦合一直是架构师的崇高目标。

通过模拟现实世界是一种设计策略，比如要做一个银行系统，在程序中不可避免创造出“账户”“交易”“转账”等结构性对象，这些对象在各个时间段发生变化，正如现实世界中的实体一样。更好的期望是：当随着时间的流逝，现实生活中的系统拥有了更多的概念，比如出现“移动支付”等新新概念时，只需要在系统中更改某个局部的部分，那么就可以为系统添加新特性。

SICP中展示了两种组织策略，这也反应两种编程思想：

1.将系统视为由互相作用的对象组成。在对象视角下，我们引入**赋值**来更改对象局部状态，并采用新的**环境模型**理解程序运行顺序。

2.将系统看作信息流的处理。在信息流视角下，**流**这一惰性求职来实现序列的按需计算。



### 赋值和局部状态

**局部状态**指的是对象私有的，描述当前状态的变量。比如一个`balance`对象，在银行系统中反映的是账户余额。在没有引入**赋值**前，balance 这个变量只是某一个值的名字，它没有“变量”的概念。根据**函数式编程**的特性，相同输入的函数总是会产生相同输出。但引入赋值后，变量变为指向某个存储位置，这个位置的值可以随着时间改变。

这样对象就可以随着时间而变化其内部的值。

没有赋值前，这种对象像是一个**常量**，它的值是固定的。当有了赋值后，变量成为同一种类型不断变化的存在。赋值使我们能够**模拟现实世界中会变的事物**，例如银行账户的余额、游戏角色的血量等。

在之前文章的例子中，通过闭包可以在环境中捕获局部变量。在闭包内使用赋值改变了捕获的变量值时，就形成了一个拥有“记忆”的对象。

```go
func makeWithdraw(initialBalance float64) func(amount float64) interface{} {
   // 局部变量，作为闭包中状态  
  balance := initialBalance 
    return func(amount float64) interface{} {
        if balance >= amount {
            balance -= amount          
            return balance            
        } else {
            return "余额不足"           
        }
    }
}

// 示例：创建两个独立的取款器
W1 := makeWithdraw(100)    // W1有自己初始余额100
W2 := makeWithdraw(100)    // W2有自己初始余额100

fmt.Println(W1(25))  // 输出: 75   （W1余额变为75）
fmt.Println(W1(50))  // 输出: 25   （W1余额变为25）
fmt.Println(W2(50))  // 输出: 50   （W2余额独立于W1，此时为50）
fmt.Println(W2(60))  // 输出: "余额不足" （W2余额不够取款）
```

在上述代码中，makeWithdraw 返回的匿名函数形成闭包，捕获了局部变量 balance。每次调用闭包都会修改并保留 balance的新值，实现了**状态随调用更新**。在这个过程中，变量`balance`对外是不可见的，它被封装在函数内部。这点很符合对象封装的思想：通过过程隐藏内部状态，只暴露操作接口。

SCIP中还介绍了另外一种**消息传递**风格来模拟对象：让对象作为一个“消息处理器”，通过不同消息来触发不同操作。

```go
// Account对象，使用闭包和消息传递模拟银行账户
func NewAccount(initialBalance float64) func(msg string, amount float64) interface{} {
    balance := initialBalance
    return func(msg string, amount float64) interface{} {
        switch msg {
        case "withdraw":
            if balance >= amount {
                balance -= amount
                return balance
            } else {
                return "余额不足"
            }
        case "deposit":
            balance += amount
            return balance
        default:
            return "未知的请求"
        }
    }
}

// 示例：创建账户并通过消息执行操作
acc := NewAccount(100)               // 新建账户，初始余额100
fmt.Println(acc("withdraw", 50))    // 输出: 50   （取款50，余额变50）
fmt.Println(acc("deposit", 40))     // 输出: 90   （存款40，余额变90）
fmt.Println(acc("withdraw", 100))   // 输出: "余额不足" （余额不足以取款100）
```

在这个例子中，NewAccount 返回一个闭包 dispatch，根据不同字符串消息执行不同分支。通过这种**消息传递**机制，模拟了一个拥有内部状态（balance）且提供多种操作（取款、存款）的对象。当对象的状态被封装，只有通过特定消息或方法才能访问和修改，这点也满足满足对象封装的思想。

赋值的优点在于可以更好“模块化”，并提高系统的抽象能力。赋值能让对象记住历史的状态，在现实例子中可以很好记录账户余额随着交易更新等业务。如果没有赋值，对于开发者来说不得不使用显式传递并返回状态：`func changeBalance(oldBalance,balance float64)initialBalance float64{...}`，这样的方式会很繁琐，让代码变得复杂难度。当状态被隐藏在对象内部时，外部使用会更简洁，每次调用会自动更新而无需调用者来维护。

当对象内部的状态对其他部分不可见时，就已经减少了模块之间的耦合，更改该对象不会影响它的使用者。例如将 balance 封装在取款函数内部，可防止外部代码随意改动余额。

赋值也不是一点缺点都没有，引入赋值后变量的值会随时间或事件发生改变，等式不在稳定可靠。赋值打破了这种数学性质X!=1!=1，一个有状态的对象中，“相同”变得模糊起来，两个账户不能引用同一个有状态的变量，就像两个存款相同的人不能共用一个账户，在程序中“余额”这种带有**状态和身份属性**的对象需要开发者投入额外的精力去思考它们的变化。

赋值引入了时间的因素，程序的结果可能依赖执行步骤的先后顺序，正确性取决于顺序，在复杂程序中时序错误会变得更加隐蔽。此外对象共享状态还可能引发并发问题(所以才引入锁的概念，这又是一个新的难题，在本文的后续章节中我们会提到)。

赋值使程序更接近现实模型，但是也牺牲了部分简单性和可靠性。



### 赋值构造模型

**赋值能让开发者实现诸如链表的就地修改**、**队列**、**表（哈希表）等数据结构。比如，在不使用赋值时，连接两个列表需要创建新列表；但有了赋值，可以原地修改指针**来改变列表结构。这带来了效率提升，但也要注意可能出现的共享结构问题。

```go
type Node struct {
    value int
    next  *Node
}
type Queue struct {
    front *Node  
    rear  *Node   
}

func NewQueue() *Queue {
    return &Queue{nil, nil}
}

func (q *Queue) Enqueue(x int) {
    newNode := &Node{value: x, next: nil}
    if q.front == nil {
        q.front = newNode
        q.rear = newNode
    } else {
        q.rear.next = newNode
        q.rear = newNode
    }
}


func (q *Queue) Dequeue() (int, bool) {
    if q.front == nil {
        return 0, false 
    }
    val := q.front.value         
    q.front = q.front.next       
    if q.front == nil {          
        q.rear = nil
    }
    return val, true
}
```

这种通过更改指针来改变队列状态的方式，在实际上的编程中十分常见。为了避免创建新队列所产生的开销，每个队列对象封装了自己的内部状态，对外只提供Enqueue和 Dequeue操作。这也进一步解释了赋值是如何支持**封装和抽象数据类型**：可以把队列看作一个独立对象，通过公共方法来操作它，而不需要关心内部是如何实现的。

赋值配合良好的数据抽象可以让程序结构直观对应所模拟的问题结构，提高扩展性和模块化。当需求新增时，只需要添加对象类型或动作，而无需推翻原有的设计。



### 环境模型和顺序执行

SICP中的**环境(**Environment**)**可以理解为**可叠加的字典**。每一层被视为一个**Frame(框架)**，其实本质上就是存放一组“名字-值”的字典，这些字典按层级连成链。检索时就会一层一层寻址，当前层找不到时就会去外层寻找，一直找到“全局层”。可以想象站在迷宫的最中心，从内一层一层向外探寻。

> **框架的产生：在环境模型中，定义操作会在当前环境框架创建新的名字绑定，而函数调用**会产生一个新的环境框架用于函数的局部变量。

在SICP中这段话比较晦涩，但是转换成Go语言的概念中可以理解成：

```
1.	创建新框架：形参绑定实参  = 调用时创建一次“调用栈帧”，让局部变量，参数都放置在这一帧
2. 
```



在SICP中展示的例子`(define x 3)`









**框架的产生：在环境模型中，定义操作会在当前环境框架创建新的名字绑定，而函数调用**会产生一个新的环境框架用于函数的局部变量。当执行 (define x 3) 时，在当前环境框架记录 x=3。当调用一个过程时，例如调用 (f 5)，系统会：

1.创建一个新框架，将形参绑定到实参

2.将这个新框架的外围环境设为被调用过程所携带的环境(闭包中记录的环境)

3.在这个新环境中执行函数体。

函数执行完毕后，这个环境依然存在(因为有可能闭包引用其中的变量作为内部状态)。这解释了闭包为何能保存状态：闭包携带来指向其创建时环境的指针。及时函数返回后，他内部定义的局部变量框架不会消失(只要有闭包引用它)，因此后续调用闭包时还能访问和修改这些保存在环境框架中的局部变量。

用环境模型来看之前的取款器例子：makeWithdraw 被调用时创建了框架 E1，其中绑定了 balance 初始值100。返回的 λ函数闭包携带了指向该环境 E1 的引用。每次调用闭包时，都在 E1 中找到并更新 balance。如果创建两个取款器 W1 和 W2，它们各自携带不同的环境（各自的balance绑定），因此互不影响 。这就解释了如何通过环境模型理解**对象的独立状态**：每个对象其实就是一个过程和一个指向自己私有环境的指针 



#### **顺序执行与时间**

有了环境模型，我们才能准确描述赋值的效果以及程序的顺序执行。**顺序执行**指程序按照指定的先后次序求值各子表达式，这一点通过Scheme的序列结构如begin来体现。(begin <exp1> <exp2> ... <expN>) 会按顺序求值各子表达式，并以最后一个的值作为结果 。顺序很重要，因为早期表达式可能产生对后续表达式可见的状态变化。例如：

```
(begin (set! x (* 2 x))
       (set! y (+ 3 x))
       y)
```

这里第二步用到了第一步计算更新后的 x。如果顺序颠倒，结果就会不同甚至错误。环境模型能很好地解释这一过程：set! x 操作不是创造新绑定，而是查找已有变量 x 的绑定位置并**就地修改**其值 。当第一步完成后，环境中 x 的值改变了；执行第二步时，从环境取出新值计算并赋给 y。整个过程严格按时间顺序更新环境中的值。

在没有赋值的纯函数式模型中，由于无副作用，执行顺序并不影响最终结果 —— 可以把表达式看作数学公式自由重排。但在命令式（有状态）模型中，**时间是程序语义的关键组成** 。我们必须按正确顺序进行操作，否则程序含义就不同。SICP特别强调**时间顺序**带来的问题：如果两个操作必须按某顺序发生（如先后更新同一变量），我们称它们存在顺序依赖；若顺序错乱可能导致错误。



#### **内部定义和局部状态**

环境模型还帮助理解**块结构**和**内部定义**。当我们在一个过程内部用 define 定义子过程或局部变量时，其实是向当前环境框架添加绑定（类似于局部“静态”变量）。这些内部定义在整个过程执行期间都存在于该过程的环境中。SICP将框架形象地比喻成“展台”（repository）来存放这些局部状态 。因此，一个过程可以有自己的环境框架，里面保存了该过程的静态局部子过程定义和变量，供过程内部任意地方使用甚至返回闭包使用。这进一步强化了**过程 = 代码 + 环境**的观念。

通过环境模型，我们重新获得对赋值程序的理解能力：我们不再把程序看作纯粹的数学代换，而是跟踪“哪块内存里的值在什么时候被改成了什么”。环境模型为后续讨论并发等问题奠定了基础，因为并发正是涉及**同一环境中的状态被多个进程交织地读取和修改**。

