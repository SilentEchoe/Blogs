---
title: SICP|模块化，对象和状态
date: 2025-10-29 13:54:00
tags: [计算机基础,读书笔记]
category: 计算机基础
---

前两章[构造数据抽象](https://silentechoe.github.io/2025/10/26/%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/)和[构造过程抽象](https://silentechoe.github.io/2025/09/28/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/)讲述了如何组合基础函数和基础数据，这些很好展现了**抽象**是如何解决大型系统的复杂性问题。抽象是一个强大的工具，它可以帮助我们解决构建大型系统中的复杂度的问题。但此外还需要一些设计策略，因为它能帮助我们使其**模块化**。

> 所谓模块化就是能让系统“自然地”分割成一些具有内聚力的，可以独立开发和维护的部分，而高内聚和低耦合一直是架构师的崇高目标。

通过模拟现实世界是一种设计策略，比如要做一个银行系统，在程序中不可避免创造出“账户”“交易”“转账”等结构性对象，这些对象在各个时间段发生变化，正如现实世界中的实体一样。更好的期望是：当随着时间的流逝，现实生活中的系统拥有了更多的概念，比如出现“移动支付”等新新概念时，只需要在系统中更改某个局部的部分，那么就可以为系统添加新特性。

SICP中展示了两种组织策略，这也反应两种编程思想：

1.将系统视为由互相作用的对象组成。在对象视角下，我们引入**赋值**来更改对象局部状态，并采用新的**环境模型**理解程序运行顺序。

2.将系统看作信息流的处理。在信息流视角下，**流**这一惰性求职来实现序列的按需计算。



### 赋值和局部状态

**局部状态**指的是对象私有的，描述当前状态的变量。比如一个`balance`对象，在银行系统中反映的是账户余额。在没有引入**赋值**前，balance 这个变量只是某一个值的名字，它没有“变量”的概念。根据**函数式编程**的特性，相同输入的函数总是会产生相同输出。但引入赋值后，变量变为指向某个存储位置，这个位置的值可以随着时间改变。

这样对象就可以随着时间而变化其内部的值。

没有赋值前，这种对象像是一个**常量**，它的值是固定的。当有了赋值后，变量成为同一种类型不断变化的存在。赋值使我们能够**模拟现实世界中会变的事物**，例如银行账户的余额、游戏角色的血量等。

在之前文章的例子中，通过闭包可以在环境中捕获局部变量。在闭包内使用赋值改变了捕获的变量值时，就形成了一个拥有“记忆”的对象。

```go
func makeWithdraw(initialBalance float64) func(amount float64) interface{} {
   // 局部变量，作为闭包中状态  
  balance := initialBalance 
    return func(amount float64) interface{} {
        if balance >= amount {
            balance -= amount          
            return balance            
        } else {
            return "余额不足"           
        }
    }
}

// 示例：创建两个独立的取款器
W1 := makeWithdraw(100)    // W1有自己初始余额100
W2 := makeWithdraw(100)    // W2有自己初始余额100

fmt.Println(W1(25))  // 输出: 75   （W1余额变为75）
fmt.Println(W1(50))  // 输出: 25   （W1余额变为25）
fmt.Println(W2(50))  // 输出: 50   （W2余额独立于W1，此时为50）
fmt.Println(W2(60))  // 输出: "余额不足" （W2余额不够取款）
```

在上述代码中，makeWithdraw 返回的匿名函数形成闭包，捕获了局部变量 balance。每次调用闭包都会修改并保留 balance的新值，实现了**状态随调用更新**。在这个过程中，变量`balance`对外是不可见的，它被封装在函数内部。这点很符合对象封装的思想：通过过程隐藏内部状态，只暴露操作接口。

SCIP中还介绍了另外一种**消息传递**风格来模拟对象：让对象作为一个“消息处理器”，通过不同消息来触发不同操作。

```go
// Account对象，使用闭包和消息传递模拟银行账户
func NewAccount(initialBalance float64) func(msg string, amount float64) interface{} {
    balance := initialBalance
    return func(msg string, amount float64) interface{} {
        switch msg {
        case "withdraw":
            if balance >= amount {
                balance -= amount
                return balance
            } else {
                return "余额不足"
            }
        case "deposit":
            balance += amount
            return balance
        default:
            return "未知的请求"
        }
    }
}

// 示例：创建账户并通过消息执行操作
acc := NewAccount(100)               // 新建账户，初始余额100
fmt.Println(acc("withdraw", 50))    // 输出: 50   （取款50，余额变50）
fmt.Println(acc("deposit", 40))     // 输出: 90   （存款40，余额变90）
fmt.Println(acc("withdraw", 100))   // 输出: "余额不足" （余额不足以取款100）
```

在这个例子中，NewAccount 返回一个闭包 dispatch，根据不同字符串消息执行不同分支。通过这种**消息传递**机制，模拟了一个拥有内部状态（balance）且提供多种操作（取款、存款）的对象。当对象的状态被封装，只有通过特定消息或方法才能访问和修改，这点也满足满足对象封装的思想。

赋值的优点在于可以更好“模块化”，并提高系统的抽象能力。赋值能让对象记住历史的状态，在现实例子中可以很好记录账户余额随着交易更新等业务。如果没有赋值，对于开发者来说不得不使用显式传递并返回状态：`func changeBalance(oldBalance,balance float64)initialBalance float64{...}`，这样的方式会很繁琐，让代码变得复杂难度。当状态被隐藏在对象内部时，外部使用会更简洁，每次调用会自动更新而无需调用者来维护。

当对象内部的状态对其他部分不可见时，就已经减少了模块之间的耦合，更改该对象不会影响它的使用者。例如将 balance 封装在取款函数内部，可防止外部代码随意改动余额。

赋值也不是一点缺点都没有，引入赋值后变量的值会随时间或事件发生改变，等式不在稳定可靠。赋值打破了这种数学性质X!=1!=1，一个有状态的对象中，“相同”变得模糊起来，两个账户不能引用同一个有状态的变量，就像两个存款相同的人不能共用一个账户，在程序中“余额”这种带有**状态和身份属性**的对象需要开发者投入额外的精力去思考它们的变化。

赋值引入了时间的因素，程序的结果可能依赖执行步骤的先后顺序，正确性取决于顺序，在复杂程序中时序错误会变得更加隐蔽。此外对象共享状态还可能引发并发问题(所以才引入锁的概念，这又是一个新的难题)。

赋值使程序更接近现实模型，但是也牺牲了部分简单性和可靠性。











