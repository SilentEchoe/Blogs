---
title: 消息队列入门
date: 2025-9-1 17:16:00
tags: [中间件,消息队列,学习笔记]
category: 中间件
---

### 前言

消息队列的雏型可以追溯到早期操作系统与分布式系统的研究。当时，跨进程通信带来了一种迫切的需求：**如何在不同进程之间高效且安全地传递信息**。直到 1993 年，IBM 推出了 MQSeries（IBM MQ 的前身），才真正将“消息中间件”这一概念推向商业化舞台，并极大地推动了分布式系统的发展。

如今，消息队列已经成为分布式系统与云原生架构中不可或缺的基础组件。



### 什么是消息队列？

队列作为一种先进先出的数据结构，消息队列在此基础上实现了更复杂的机制。对于开发者来说，可以直接将消息队列视为一个消息容器，由该容器负责实现严格有序的数据排列与数据安全的保证。

在传统的单体系统中，依靠系统时间戳就能较为简单地实现先进先出的线性顺序。但在分布式系统中，**“不可靠的时钟”** 显然无法作为唯一的凭证：不同节点的物理时钟存在偏差，网络延迟又可能导致事件发生顺序与时间戳顺序不一致，从而破坏了 FIFO 的语义。

因此，在分布式场景下，无论是 **高并发业务**、**金融系统对强一致性的严格要求**，还是 **云原生环境中的弹性架构设计**，消息队列必须提供更强的保证。它不仅要容纳来自多个服务的消息，还要在此基础上维持严格的顺序控制与可靠交付，以确保 FIFO 原则在复杂环境下依然成立。





#### 异步处理

在同步请求的情况下，当客户端发起一个请求，服务端接收请求后，会立即进行数据或业务逻辑的处理，操作成功后再将结果返回给客户端。此时客户端必须等待整个处理过程，这个请求耗时由网络，服务端业务处理，数据库的读写等多种因素来决定。

当引入消息队列后，服务端在接受到客户端发起的请求，会直接将请求写入到消息队列，然后立马返回给客户端，由其他独立的消费者服务异步处理后续任务。这种模式能显著减少客户端等待时间，在高并发的场景中，消息队列还能**削峰**的作用，不仅提高系统吞吐量，也提升整体的健壮性（避免服务被流量高峰直接冲垮）。



![image-20250903151702750](https://raw.githubusercontent.com/SilentEchoe/images/main/image-20250903151702750.png)

用户提交的请求在写入消息队列后就会立即返回给用户，但这不意味着请求一定会被成功处理。服务端在后续消费这些业务消息时，可能会出现**消息处理失败**，比如业务逻辑异常，服务处理处理超时等。所以需要配合重试机制，比如重试策略来保证最终一致性。

单机系统中实现一个“异步处理”相对简单，Go语言中的`channel`就能起到"异步"和"解耦"的作用，生产者把消息写入`chan`，消费者`goroutine`从`chan`读取信息再进行处理。但是我想说在一个分布式系统中，这完全是两个层面的概念。如果单纯引入异步处理而引入消息队列，能获得的最大好处在于可以**跨进程，跨主机，跨数据**。`channel`只能在一个进程内使用，在微服务架构中，生产者和消费者是不同服务，甚至跑在不同节点。`channel`中如果服务崩溃则全量丢失，而消息队列提供可靠的持久化以及指定offset消费的能力。

channel解决的是同一进程内的异步通信，而消息队列解决的是分布式系统的异步通信。



#### 削峰/限流

在大型系统中，流量往往会在特定时间段集中爆发，例如上下班的早晚高峰、促销活动或秒杀场景。由于数据库的并发承载能力通常存在上限，直接将所有请求写入数据库可能导致系统过载甚至崩溃。

比较常见的做法是先由业务服务将用户请求写入消息队列，再由消费服务按照一定速率逐步处理这些事务性消息，这一过程本质上是一种延迟执行。"削峰"机制将消息队列作为服务与数据库之间的"缓冲区"，吸收瞬时流量带来的冲击，并将一部分流量延后处理，使系统在高并发场景下能够更平稳地运行。

![image-20250904111053832](https://raw.githubusercontent.com/SilentEchoe/images/main/image-20250904111053832.png)

消费服务在从消息队列中读取并处理请求时，往往会以一个相对稳定的速率来执行，这本身就体现了**限流**的效果。但是任需警醒的是：系统可能只是表面经受住了流量带来的冲击，实际上可能因为消费的速度过慢，导致消息队列内部产生积压。

通过“增加消费服务”这种方式可以简单粗暴地解决该问题，但这并非一劳永逸的解决方案。系统依然需要针对消费速率和队列的积压情况进行观测。











