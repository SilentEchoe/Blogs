---
title: SICP|构造数据抽象
date: 2025-10-09 10:06:00
tags: [计算机基础,读书笔记]
category: 计算机基础

---

### 前言

在[构造过程抽象](https://silentechoe.github.io/2025/09/28/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/)一文中，我们讨论了**过程的抽象**这一思想。通过复合过程，我们得以提升程序设计时的概念层次，使设计更加模块化，并增强语言的表达能力。

不过，在那个阶段中，所有函数操作的都是最简单的数值类型，而简单的数据结构表达能力是不够的，许多程序在设计之初就是为了模拟真实世界中多层次的结构和关系。正如定义过程让我们能在更高层次上组织计算一样，同样的，能够构造复合数据的能力，也将使我们得以在此比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。



### 什么是数据抽象？

在SICP中数据抽象被解释为一种方法学，它可以将一个复合对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。它的核心目的是为了**使用数据时，只关心“数据能干什么”，而不去关心它是如何实现的。**

> 数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。我们的程序中使用数据的方式应该是这样的:除了完成当前工作所必要的东西之外，它们不对所用数据做任何多余的假设。与此同时，一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。在我们的系统中，这样两个部分之间的界面将是一组过程，称为“选择函数”和“构造函数”。

比如在程序里面操作一个坐标点位，如果不使用数据抽象，可能直接使用数组，Map，结构体等数据结构：

```go
p := [2]float64{3, 4}  
fmt.Println(p[0], p[1])
```

这样的数据结构会有一个问题：使用这个数据结构的开发者，必须知道每个下标代表的值是纵坐标还是横坐标，一旦数据结构发生变化，那么所用引用到该数据的地方都需要更改。

如果用数据抽象，不直接操作数组，而直接提供一组“接口”：

```go
type Point struct{ x, y float64 }

func MakePoint(x, y float64) Point { return Point{x, y} }
func X(p Point) float64           { return p.x }
func Y(p Point) float64           { return p.y }

p := MakePoint(3, 4)
fmt.Println(X(p), Y(p))
```

使用者无需知道内部是由结构体还是数组来构建，只需要把数据的构建和如何使用数据分开，调用者通过“构造函数”和“选择函数”来操作数据，那么就能自由地改变数据实现，无需更改上层的业务逻辑。

**抽象屏障**在表述中更像是一条分界线，用来把调用者和底层的实现细节隔离开。在上述的例子中，`MakePoint`就是构造函数，而`X`和`Y`是选择函数。这么做的好处在于：通过分界线来屏蔽细节，当有一天底层发生改变时上层的业务也无需改动。

```go
type Point map[string]float64

func MakePoint(x, y float64) Point { return Point{"x": x, "y": y} }
func X(p Point) float64            { return p["x"] }
func Y(p Point) float64            { return p["y"] }
```

使用Map替换struct，但是对**fmt.Println(X(p), Y(p))**函数来说无需改动，可以看到所有的改动都发生在屏障内部(MakePoint/X/Y)。

抽象屏障是为了隔离系统中不同的层次，每一层都可以使用数据的抽象程序与实现数据抽象的程序分开。

> 这里不是OOP中的抽象类和实现类，而是从使用的角度来说，用这种抽象的概念来“分隔数据的使用者与数据的实现”。
>
> 抽象屏障的意义不是为了方便，而是为了稳定和解耦。用接口来屏蔽结构。

表达方式的选择会对操作它的程序产生影响。这才是关键，如果后来表示的方式改变了，所有受影响的程序也需要随之改变。对于大型程序而言，这种工作非常耗时，而且代价极其高，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。

借助数据抽象的思想就能设计出不会被数据表示的细节纠缠的程序，使程序能够保持很好的弹性，得以应用到不同的具体表示上。



#### 数据到底是什么？

通过过程组合形成更复杂的过程，通过将多个数据对象组合在一起形成复合数据对象，这种组合本身只是过程。在SICP中甚至有例子可以只用过程来表示数据。比如上述的`Point`结构体，通常情况下对外表述可能会说这个结构体就是数据。但是同样地可以用**闭包(过程)**来进行改写：

```go
func MakePoint(x, y float64) func(string) float64 {
	return func(op string) float64 {
		if op == "x" {
			return x
		}
		return y
	}
}

func X(p func(string) float64) float64 {
	return p("x")
}

func Y(p func(string) float64) float64 {
	return p("y")
}

p := MakePoint(3, 4)
fmt.Println(X(p), Y(p))
```

即使不使用高级编程语言内置的基础数据结构，也能通过函数来进行表达。调用放在执行`MakePoint`函数和`fmt.Println`时输出与结构体改写的并无区别。

**可见，数据并不依赖“存储结构”，而是由其定义的“操作”所决定的。**

> 不存在天然的数据，只有我们设计出的接口与行为。

SICP中实现了序对这一数据抽象，它是一种复合的结构，它会将两个对象组合成一个新的"对象"。用Go语言表达大概是这样的：

```go
type Pair func(func(interface{}, interface{}) interface{}) interface{}

func Cons(a, b interface{}) Pair {
	return func(f func(interface{}, interface{}) interface{}) interface{} {
		return f(a, b)
	}
}

func Car(p Pair) interface{} {
	return p(func(a, b interface{}) interface{} { return a })
}

func Cdr(p Pair) interface{} {
	return p(func(a, b interface{}) interface{} { return b })
}
```

这里的Pair没有使用Map，数组，结构体，它使用闭包。但是它在行为上完全等价于一个包含a和b的二元组。



### 层次性数据和闭包性质

复合数据不等于直接把两个数放在一起，而是为了把对象和关系组合起来，形成更复杂的层次结构。它表达的是如何用少量组合规则无限扩展表达能力。

> 通过复合数据，我们不仅能表示单个对象，还能表示对象之间的结构和关系

SICP中用"**序列**"组合成"链表"来作为构建层次性数据结构的示例：

```go
package main

import "fmt"

type Pair struct {
	Car interface{}
	Cdr interface{}
}

func Cons(a, b interface{}) *Pair {
	return &Pair{Car: a, Cdr: b}
}

func Car(p *Pair) interface{} {
	return p.Car
}

func Cdr(p *Pair) interface{} {
	return p.Cdr
}

func PrintList(list *Pair) {
	for list != nil {
		fmt.Println(Car(list))
		next := Cdr(list)
		if next == nil {
			break
		}
		list = next.(*Pair)
	}
}

func main() {
	l := Cons(1, Cons(2, Cons(3, nil)))
	PrintList(l)
}

$ 1 -> 2 -> 3 -> nil
```

一个Pair可以组合两个元素，两个元素可以继续嵌套成Pair。链表就是多重嵌套的序队，用相同的构造方式把数据一层一层堆叠起来就形成了“结构”，这就是**层次性**的雏形。通过简单的组合操作，可以无限嵌套构造更加复杂的结构，比如链表，图，树等。

```go
ree := Cons(1, Cons(Cons(2, Cons(3, nil)), Cons(4, nil)))

        (1)
       /   \
     (2 3)  (4)
```

SICP中谈论的“**闭包性质（Closure Property）**”可以视为：当一种组合操作的结果依然是同一种类型的元素时，可以说这个操作具有闭包性。

这意味着编程语言中只需要包含少量的基础数据结构，通过闭包的性质，**可以递归构造出任意复杂的数据结构。**在云原生中，Kubernetes 中的Deployment,StatefulSets本质上也是层层组合而成(Pod模版+ReplicaSet)，只要基础的规则稳定实现，就能不断嵌套成更复杂的结构，也无需改动底层的实现机制。

闭包不是某一种语法糖，可以将其视为一种设计原则，比如JSON中一个对象嵌套另外一个对象，也是闭包性质体现。

> 如果有一种组合方式，它组合两个对象之后返回的结果，也可以被同样的方式再次组合，那么这种组合方式具有闭包性质。

不同于编程语言中的“闭包”(它指的是函数可以捕获它定义环境中的自由变量)，闭包性质关注的是数据结构和操作的自我封闭性，不是函数捕获环境的行为，这点要区分来看待。闭包函数是编程语言的机制，闭包性质是抽象设计的结构性特征，这两者经常与“递归”和“抽象”同时出现，所以容易混淆，这点要特别说明。



#### 序列作为接口

SICP中引入了**序列抽象**作为操作层的统一接口，这里“序列”不是指某一种具体的数据结构，而是一种**约定的抽象接口**，它指的是一类可以被遍历，组合，变换的数据结构。它不特指某种数据结构，只要满足接口的约定就行。

> 当我们拥有了闭包性质，就可能有许多种不同方式来表示同样的概念。但如果我们为这些结构约定一套标准接口，那么我们就能对所有这些不同表示采取相同的操作方式。



```go
package main

import (
    "fmt"
)

type Sequence[T any] interface {
    // Next 返回下一个元素和一个 bool 表示是否还有
    Next() (T, bool)
    // Map 返回一个新的 Sequence，其中每个元素经 f 变换
    Map(func(T) T) Sequence[T]
    // Filter 返回一个新的 Sequence，仅包含满足 p 的元素
    Filter(func(T) bool) Sequence[T]
}

type sliceSequence[T any] struct {
    data []T
    idx  int
}

func NewSliceSequence[T any](data []T) *sliceSequence[T] {
    return &sliceSequence[T]{data: data, idx: 0}
}

func (s *sliceSequence[T]) Next() (T, bool) {
    if s.idx >= len(s.data) {
        var zero T
        return zero, false
    }
    v := s.data[s.idx]
    s.idx++
    return v, true
}

func (s *sliceSequence[T]) Reset() {
    s.idx = 0
}

func (s *sliceSequence[T]) Map(f func(T) T) Sequence[T] {
    s.Reset()
    newData := make([]T, 0, len(s.data))
    for v, ok := s.Next(); ok; v, ok = s.Next() {
        newData = append(newData, f(v))
    }
    return NewSliceSequence(newData)
}

func (s *sliceSequence[T]) Filter(p func(T) bool) Sequence[T] {
    s.Reset()
    newData := make([]T, 0, len(s.data))
    for v, ok := s.Next(); ok; v, ok = s.Next() {
        if p(v) {
            newData = append(newData, v)
        }
    }
    return NewSliceSequence(newData)
}

func main() {
    ints := []int{1, 2, 3, 4, 5, 6}
    seq := NewSliceSequence(ints)

    // Map: 每个元素乘以2
    mapped := seq.Map(func(x int) int {
        return x * 2
    })

    // Filter: 只保留 > 6 的元素
    filtered := mapped.Filter(func(x int) bool {
        return x > 6
    })
  
    for v, ok := filtered.Next(); ok; v, ok = filtered.Next() {
        fmt.Println(v)  // 输出：8, 10, 12
    }
}
```

`Sequence[T]`是一个通用的接口，无论底层实现的是什么，只要实现了这个接口就能使用相同的操作。Map 和 Filter 返回的依然是`Sequence[T]`，这说明操作的结果依然是序列，使用者不需要关心底层数据是什么，只要使用`Next()` `Map()` `Filter()`就好了。

这种抽象的好处在于不用为每种数据结构分别编写具体的逻辑，Map、Filter、Reduce 这样的操作可以“统一”处理所有结构，结构的差异又可以被隐藏在抽象屏障后面，操作却又能保持一致。也就是说可以像操作数组一样去操作树，图，流等。

在现代的架构中使用接口来屏蔽实现类的方式被普遍应用，复杂性不会和结构绑定，而是转移到了更抽象的”操作层“(业务层或领域层Domain Layer)。







### 参考资料

https://coolshell.cn/articles/21164.html
