### 数据应该如何抽象？

简单的数据是不够的，许多程序在设计时就是为了模拟复杂的现象，因此就需要构造一些计算对象。

为什么在程序设计语言中需要复合数据呢？和需要复合过程的原因一样：同样是为了提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样，能够构造复合数据的能力，也将使我们得以在此比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。

复合数据的使用可以进一步提高程序的模块性。如果可以直接将有理数本身当作对象的方式下操作它们，那么也就可能把处理有理数的那些程序部分，与有理数如何表示的细节隔离开。这种将程序中处理数据对象的表示的部分，与处理数据对象的使用的部分相互隔离的技术非常具有一般性，形成一种称为**数据抽象**的强有力的设计方法学。

复合对象的使用将真正提高程序设计语言的表达能力。形成“线性组合” ax + by 可能会写成：

```go
func linearCombination(a,b,x,y int) int{
  return (a * x) + (b * y) 
}
```

如果关心的不仅仅是数，希望表述的是基于**加**和**乘**形成线形组合的思想，针对的可以是有理数，复述，多项式或者其他东西，我们可能将其表达成:

```go
func linearCombination(a,b,x,y int) int{
  return add(mul(a,x),mul(b,y))
}

func add(a,b int)int{
  return a+b
}

func mul(a,b int)int{
  return a*b
}
```

这里最关键的是，linearCombination 函数需要知道 abxy所有的操作，它们应该是什么类型的数据，但是对linearCombination函数来说它们是什么类型的数据是无关的。

形成复合数据的关键在于，程序设计语言里应该提供某种"粘合剂"，它们可以把一些数据对象组合起来，形成更复杂的数据对象。



### 闭包

什么是闭包？

简单来说，闭包让函数能访问它的外部作用域。

```go
func main(){
	i := 1
	func(){
		fmt.Println(i)
	}()
}
```

闭包是函数和其外部作用域的结合，允许内部函数访问外部函数的作用域中的变量，即使外部函数已经完成执行。

可以用闭包创建私有变量，防止外部修改变量的值。

闭包是函数式编程的重要组成部分，可以用于实现各种函数式编程技术，比如柯里化（currying）和函数组合。

> 用于组合数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象。
> 复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。

闭包性质是任何一种组合功能的威力的关键要素，因为它使我们能够建立起 **层次性** 的结构，这种结构由一部分构成，而其中的各个部分又是又它们的部分构成，并且可以如此继续下去。

组合式的成员本身还可以是组合式。



### 符号表达式

符号表达式的基本部分可以是任意的符号，不一定就是数。一个给定的数学函数可以通过许多不同的计算过程计算一样，对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合。



### 什么是数据抽象？

数据抽象是一种方法学，它使我们能将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。

数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。我们的程序中使用数据的方式应该是这样的:除了完成当前工作所必要的东西之外，它们不对所用数据做任何多余的假设。与此同时，一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。在我们的系统中，这样两个部分之间的界面将是一组过程，称为“选择函数”和“构造函数”。



**序对**

SICP中实现了序对这一数据抽象，它是一种复合的结构，它会将两个对象组合成一个新的"对象"。用Go语言表达大概是这样的。

```go
type Pair struct {
    Car interface{}
    Cdr interface{}
}

func Cons(a, b interface{}) Pair {
    return Pair{Car: a, Cdr: b}
}

func Car(p Pair) interface{} {
    return p.Car
}

func Cdr(p Pair) interface{} {
    return p.Cdr
}
```

序对可以用作构造任意种类的复杂数据结构的通用的基础构件。从序对构造起来的数据对象称为表结构数据。

数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。



序列

利用序对可以构造出的一类数据结构式**序列**——一批数据对象的一种有序汇集。采用序对表示序列的方式有很多，一种最直接的是构建出一个“链表”，将有序的序对串联起来。



Map 是一种很重要的结构，不仅因为它代表了一种公共模式，而且因为它建立了一种处理表的高层抽象。

程序的递归结构将人的注意力吸引到对于表中逐个元素的处理上。通过map定义scale-list 抑制了这种细节层面上的情况，强调的是从元素表导结果表的一个缩放变换。

> 这两种定义形式之间的差异，在于对同一个过程的不同思考方式。从作用上来看，map建立了一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。
> 这种抽象会提供新的灵活性，使我们有可能在保持从序列到序列的变换操作框架的同时，改变序列实现的底层细节。



树

序列的元素就是树的分支，那些本身也是序列的元素形成了树中的子树。

递归是处理树结果的一种很自然的工具，对于树的操作归结于对它们的分支的操作，再将这种操作归结为对分支的分支的操作。如此下去，直至达到了树的叶子。



### 抽象屏障

抽象屏障是为了隔离系统中不同的层次，每一层都可以使用数据的抽象程序与实现数据抽象的程序分开。

> 这里不是OOP中的抽象类和实现类，而是从使用的角度来说，用这种抽象的概念来“分隔数据的使用者与数据的实现”。
> 用接口来屏蔽结构。

抽象屏障的意义不是为了方便，而是为了稳定和解耦。

每一层次中的过程构成了所定义的抽象屏障的界面，联系起系统中不同层次。它的好处在于程序变得跟容易维护和修改。任意一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言提供的基本数据结构表示。

表达方式的选择会对操作它的程序产生影响。这点才是关键，如果后来表示的方式改变了，所有受影响的程序也需要随之改变。对于大型程序而言，这种工作非常耗时，而且代价极其高，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。



借助数据抽象的思想就能设计出不会被数据表示的细节纠缠的程序，使程序能够保持很好的弹性，得以应用到不同的具体表示上。





由序对构成序列的这些操作，都是为了得到模块化的程序，一些比较独立的片段的组合构成的设计。通过提供一个标准部件的库，并使这些部件都有这一些能以各种灵活方式相互连接的约定界面，这样就能更好地去一些模块化的设计。

因为在工程中，模块化结构是控制复杂性的一种策略。



描述一种语言时，应该将注意力集中到语言的基础原语，它的组合手段以及它的抽象手段。



所用的数据在组合的方式下的闭包性质非常重要，因为可以用几个操作就可以构造出复杂的结构。





