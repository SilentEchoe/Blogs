---
title: SICP|构造数据抽象
date: 2025-10-09 10:06:00
tags: [计算机基础,读书笔记]
category: 计算机基础

---

### 前言

在[构造过程抽象](https://silentechoe.github.io/2025/09/28/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/)一文中，我们讨论了**过程的抽象**这一思想。通过复合过程，我们得以提升程序设计时的概念层次，使设计更加模块化，并增强语言的表达能力。

不过，在那个阶段中，所有函数操作的都是最简单的数值类型，而简单的数据结构表达能力是不够的，许多程序在设计之初就是为了模拟真实世界中多层次的结构和关系。正如定义过程让我们能在更高层次上组织计算一样，同样的，能够构造复合数据的能力，也将使我们得以在此比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。



### 什么是数据抽象？

在SICP中数据抽象被解释为一种方法学，它可以将一个复合对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。它的核心目的是为了**使用数据时，只关心“数据能干什么”，而不去关心它是如何实现的。**

> 数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们就像是在“抽象数据”上操作一样。我们的程序中使用数据的方式应该是这样的:除了完成当前工作所必要的东西之外，它们不对所用数据做任何多余的假设。与此同时，一种“具体”数据表示的定义，也应该与程序中使用数据的方式无关。在我们的系统中，这样两个部分之间的界面将是一组过程，称为“选择函数”和“构造函数”。

比如在程序里面操作一个坐标点位，如果不使用数据抽象，可能直接使用数组，Map，结构体等数据结构：

```go
p := [2]float64{3, 4}  
fmt.Println(p[0], p[1])
```

这样的数据结构会有一个问题：使用这个数据结构的开发者，必须知道每个下标代表的值是纵坐标还是横坐标，一旦数据结构发生变化，那么所用引用到该数据的地方都需要更改。

如果用数据抽象，不直接操作数组，而直接提供一组“接口”：

```go
type Point struct{ x, y float64 }

func MakePoint(x, y float64) Point { return Point{x, y} }
func X(p Point) float64           { return p.x }
func Y(p Point) float64           { return p.y }

p := MakePoint(3, 4)
fmt.Println(X(p), Y(p))
```

使用者无需知道内部是由结构体还是数组来构建，只需要把数据的构建和如何使用数据分开，调用者通过“构造函数”和“选择函数”来操作数据，那么就能自由地改变数据实现，无需更改上层的业务逻辑。

**抽象屏障**在表述中更像是一条分界线，用来把调用者和底层的实现细节隔离开。在上述的例子中，`MakePoint`就是构造函数，而`X`和`Y`是选择函数。这么做的好处在于：通过分界线来屏蔽细节，当有一天底层发生改变时上层的业务也无需改动。

```go
type Point map[string]float64

func MakePoint(x, y float64) Point { return Point{"x": x, "y": y} }
func X(p Point) float64            { return p["x"] }
func Y(p Point) float64            { return p["y"] }
```

使用Map替换struct，但是对**fmt.Println(X(p), Y(p))**函数来说无需改动，可以看到所有的改动都发生在屏障内部(MakePoint/X/Y)。

抽象屏障是为了隔离系统中不同的层次，每一层都可以使用数据的抽象程序与实现数据抽象的程序分开。

> 这里不是OOP中的抽象类和实现类，而是从使用的角度来说，用这种抽象的概念来“分隔数据的使用者与数据的实现”。
>
> 抽象屏障的意义不是为了方便，而是为了稳定和解耦。用接口来屏蔽结构。

表达方式的选择会对操作它的程序产生影响。这才是关键，如果后来表示的方式改变了，所有受影响的程序也需要随之改变。对于大型程序而言，这种工作非常耗时，而且代价极其高，除非在设计时就已经将依赖于表示的成分限制到很少的一些程序模块上。

借助数据抽象的思想就能设计出不会被数据表示的细节纠缠的程序，使程序能够保持很好的弹性，得以应用到不同的具体表示上。



#### 数据到底是什么？

通过过程组合形成更复杂的过程，通过将多个数据对象组合在一起形成复合数据对象，这种组合本身只是过程。在SICP中甚至有例子可以只用过程来表示数据。比如上述的`Point`结构体，通常情况下对外表述可能会说这个结构体就是数据。但是同样地可以用**闭包(过程)**来进行改写：

```go
func MakePoint(x, y float64) func(string) float64 {
	return func(op string) float64 {
		if op == "x" {
			return x
		}
		return y
	}
}

func X(p func(string) float64) float64 {
	return p("x")
}

func Y(p func(string) float64) float64 {
	return p("y")
}

p := MakePoint(3, 4)
fmt.Println(X(p), Y(p))
```

即使不使用高级编程语言内置的基础数据结构，也能通过函数来进行表达。调用放在执行`MakePoint`函数和`fmt.Println`时输出与结构体改写的并无区别。

**可见，数据并不依赖“存储结构”，而是由其定义的“操作”所决定的。**

> 不存在天然的数据，只有我们设计出的接口与行为。

SICP中实现了序对这一数据抽象，它是一种复合的结构，它会将两个对象组合成一个新的"对象"。用Go语言表达大概是这样的：

```go
type Pair func(func(interface{}, interface{}) interface{}) interface{}

func Cons(a, b interface{}) Pair {
	return func(f func(interface{}, interface{}) interface{}) interface{} {
		return f(a, b)
	}
}

func Car(p Pair) interface{} {
	return p(func(a, b interface{}) interface{} { return a })
}

func Cdr(p Pair) interface{} {
	return p(func(a, b interface{}) interface{} { return b })
}
```

这里的Pair没有使用Map，数组，结构体，它使用闭包。但是它在行为上完全等价于一个包含a和b的二元组。



### 层次性数据和闭包性质

> 通过复合数据，我们不仅能表示单个对象，还能表示对象之间的结构和关系

但是复合数据不等于直接把两个数放在一起，而是可以把对象和关系组合起来，形成更复杂的层次结构。基于**序对**可以进一步构建**链表**：

```go
package main

import "fmt"

type Pair struct {
	Car interface{}
	Cdr interface{}
}

func Cons(a, b interface{}) *Pair {
	return &Pair{Car: a, Cdr: b}
}

func Car(p *Pair) interface{} {
	return p.Car
}

func Cdr(p *Pair) interface{} {
	return p.Cdr
}

func PrintList(list *Pair) {
	for list != nil {
		fmt.Println(Car(list))
		next := Cdr(list)
		if next == nil {
			break
		}
		list = next.(*Pair)
	}
}

func main() {
	l := Cons(1, Cons(2, Cons(3, nil)))
	PrintList(l)
  PrintList(l)
}
```

链表就是嵌套的序队，用相同的构造方式把数据一层一层堆叠起来就形成了“结构”，这就是**层次性**的雏形。通过简单的组合操作，可以无限嵌套构造更加复杂的结构，比如链表，图，树等。

```go
ree := Cons(1, Cons(Cons(2, Cons(3, nil)), Cons(4, nil)))

        (1)
       /   \
     (2 3)  (4)
```



#### 闭包性质

SICP中谈论的“闭包性质（Closure Property）”

