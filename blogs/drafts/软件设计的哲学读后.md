---
title: 《软件设计的哲学》读后
date: 2025-08-20 10:22:00
tags: [设计,读后]
category: 阅读
---

《软件设计的哲学》一书通篇围绕"复杂性"进行讨论，作者描述各种导致系统复杂度提升的可能性，也提出了一些通用的思想来降低复杂性。

作者将复杂性表现分成三种：变更放大，对于软件开发人员来说，如果需要更改多处才能完成一个需求，那么它就是复杂的；认知复杂，如果需要掌握大量的知识才能完成一项任务，当缺少其中部分知识的认知而来带风险，那么就是复杂的;未知复杂：开发人员必须知晓某些信息才能去完成需求，那么这种复杂性是最糟糕的，因为很有可能开发人员连预防风险的认知都没有。

这三种复杂性的表现几乎随处可见，更改一个需求时需要更改多个类，文件？是否要花很长时间阅读旧代码？是否完全理解该任务所涉及的知识点？更改需求时是否要了解该需求的相关性？对于影响范围有个大概预估？

复杂性不是突然出现的，它更像是一个堆砌的过程，本文将会对该书的部分内容进行综合和讨论，将更多的注意力放在技术的范畴，而忽略其工程治理的部分。



### 如何降低复杂性？

有两种方式可以降低复杂性：1.通过使代码更简单，更显而易见来降低复杂性。2.将复杂性封装起来，也就是通过模块化设计来隐藏细节。

使代码更简单好像是所有[黑客]的追求，各类技术书籍一直强调简单意味着美，优雅来源于简约。在算法领域，用较少的元素完成大量的工作一直被认为是优雅的。在现实世界中则存在更复杂的争论，如果一个算法以极少的代码行数实现，但是其他开发人员无法理解。那么这算是简单还是复杂？

用行数来衡量简单和复杂是不准确的，大量浅显且重复的函数散落在系统各处，这不会降低复杂性，只会提高复杂性。不同的编程语言实现同一需求所产生的代码行数也是不一样的，比如Go语言中大量的 `if err != nil`判断，这些重复代码几乎占据函数的一半。但是它简单易懂，不会对开发人员的认知产生挑战。








