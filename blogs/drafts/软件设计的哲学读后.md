---
title: 《软件设计的哲学》读后
date: 2025-08-20 10:22:00
tags: [设计,读后]
category: 阅读
---

《软件设计的哲学》一书通篇围绕"复杂性"进行讨论，作者描述各种导致系统复杂度提升的可能性，也提出了一些通用的思想来降低复杂性。

作者将复杂性表现分成三种：变更放大，对于软件开发人员来说，如果需要更改多处才能完成一个需求，那么它就是复杂的；认知复杂，如果需要掌握大量的知识才能完成一项任务，当缺少其中部分知识的认知而来带风险，那么就是复杂的;未知复杂：开发人员必须知晓某些信息才能去完成需求，那么这种复杂性是最糟糕的，因为很有可能开发人员连预防风险的认知都没有。

这三种复杂性的表现几乎随处可见，更改一个需求时需要更改多个类，文件？是否要花很长时间阅读旧代码？是否完全理解该任务所涉及的知识点？更改需求时是否要了解该需求的相关性？对于影响范围有个大概预估？

本文将会对该书的部分内容进行综合和讨论，将更多的注意力放在技术的范畴，而忽略其工程治理的部分。



### 如何降低复杂性？

有两种方式可以降低复杂性：1.通过使代码更简单，更显而易见来降低复杂性。2.将复杂性封装起来，也就是通过模块化设计来隐藏细节。

使代码更简单好像是所有[黑客]的追求，各类技术书籍一直强调简单意味着美，优雅来源于简约。在算法领域，用较少的元素完成大量的工作一直被认为是优雅的。现实世界中则存在更复杂的争论，如果一个算法以极少的代码行数实现，但是其他开发人员无法理解。那么这算是简单还是复杂？

行数并不能衡量复杂性，散落在系统各处浅显重复函数只会增加复杂性。不同的编程语言实现同一需求所产生的代码行数也是不一样的，比如Go语言中大量的 `if err != nil`判断，这些重复代码几乎占据函数的一半。但是它简单易懂，不会对开发人员的认知产生挑战。

单一的维度是无法估量复杂性的，书中描述了一个方式来进行估算：**系统的总体复杂度由每个部分的复杂度乘以开发人员在该部分花费的时间加权**。这段话看起来既拗口又难以理解，但是可以通过一个理想的状态来反推它的定义：

> 我们希望一个系统是显而易见的，开发人员可以不用费力思考就可以明白要做什么，同时确信他所做的是正确的。

一个显而易见降低复杂性的小技巧就是：不要使用特例来构建正常的业务需求。这种特例通常使用某个变量硬编码在代码中，使用`if`切成不同的逻辑分支。这样虽然能简单快速实现需求，也不会增加开发人员的的认知负担，但是它极容易泛滥，如果没有一个统一的标识符来描述它的一致性，那么很有可能相同的变量充斥多个模块，这样在后续的版本迭代中需要更改多个地方才能继续拓展。

复杂性由依赖性和模糊性组成。依赖性是软件组成的基础，不可能完全消除它，但是软件设计的目标之一就是减少依赖关系的数量，尽可能使依赖关系保持简单明了。

回到简单，另外一个例子就是变量名，如果一个变量名太过于"晦涩"或者说它过于"通用"，以至于`count`这样的变量名随处可见。模糊性会随着时间的推移进一步提高复杂性，当然另一类开发人员会秉持着"变量名越短越好"的观念。你可以在各个社群中看到各种抱怨，简短的变量名缺乏关键信息，过长的变量名显得臃肿难以记忆，这些观点互相碰撞。这两者只是风格问题，当你意识到臃肿就应该思考一个新的变量名来简化它，意识到无法通过几个简单字母就能准确表述其中的意义，那么就应该考虑更多的单词来形容它。理想的状态下它们随着版本迭代最终会趋于一个[中庸]的状态，如果实在无法形容其复杂性，那么至少能为其加上注释，至少要在同一个系统内保持风格的统一。

最糟糕的状况是什么都不做，随着这些复杂性和模糊性不断堆叠，当然这又涉及到架构治理的概念，也就不在本文的讨论范围内。





### 模块化应该如何设计？

最理想的情况下每一个模块都独立于其他模块，开发者可以在模块内独立工作，而对模块一无所知。良好设计的模块将所有改动仅限于该模块内，在架构设计中已经划分好优秀的边界，那么基于这样理想状态下，系统的复杂程度就是设计得最差的模块的复杂度。它不再是一个复杂的数学公式，而是一个"木桶短板理论"。

更普遍的情况则是模块与模块互相依赖，互相调用，当开发者更改其中一个模块，那么也需要更改上下游的其他模块。更糟糕的情况是更改了某个函数的入参，则不可避免更改整个调用链路。微服务中的复杂程度之所以呈几何倍数增长，在于数个服务共同完成同一个功能模块，当其中一个服务发生改变时整个请求链路都会受到影响。

当然对于系统中的独立模块来说还不至于这么复杂，为了进一步降低复杂性模块一般会分成两个部分：接口和实现。接口只描述模块对外提供的功能，而不描述具体细节。实现则执行接口所承诺的目标。这样开发者无需深入了解模块是如何实现的，只需知晓应该如何调用，以及返回值的意义(更好的情况下还会有注释)。

> 模块化设计的目标是最大程度**减少模块之间的依赖性。**

大部分编程语言都会确保接口中方法调用的安全性，静态语言中编译器会检查接口方法的参数和返回值以及类型是否正确，动态语言虽然没有编译器的严格检查，但是会通过鸭子类型(Duck Typing)来遵从"契约"，从这点来看接口更像是模块化中严格对外的出入口。

书中提到:**在模块化编程中，每个模块以其接口的形式提供抽象。该接口提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此接口中会将其省略掉**。其背后代表的是高度抽象化，将不重要的细节屏蔽掉，只保留真正重要的部分。在这个过程极容易出错：接口包含了不必要的复杂信息；接口忽略了真正重要的细节;这两种情况都会增加开发者的认知负担，前者过于模糊不清，后者则无法达到预期的目的。

ORM提供了不同数据库读写的实现，它的本质是为了屏蔽各个数据库的差异，以一个统一规范的接口暴露读写方法，让开发者使用相同的业务代码就能支持多种数据库。但是数据库中的**事务隔离，锁等待，并发控制**等细节都被屏蔽掉了。不同数据库的隔离级默认值也不相同，所以ORM通常会提供Begin/Commit/Rollback等方法对外暴露事务的控制。

抽象是为了管理复杂性。

一个好的模块应该是通过简单的接口实现强大的功能，最有代表性的是Unix操作系统提供文件I/O机制，通过打开，读/写，查找，关闭五个接口来实现各种复杂的问题。

```c
int open(const char* path, int flags, mode_t permissions);
ssize_t read(int fd, void* buffer, size_t count);
ssize_t write(int fd, const void* buffer, size_t count);
off_t lseek(int fd, off_t offset, int referencePosition);
int close(int fd);
```

Unix I/O接口的实现已经发生了根本性的变化，从早期的磁带到机器硬盘再到现在的SSD；从本地文件系统到网络文件系统(NFS)，再到各种分布式文件系统;但是基于内核调用并没有改变，因为它们在抽象层次上足够简洁，且几乎覆盖了所有I/O场景。无论是磁盘文件，Socket，设备驱动等都可以通过这套接口来访问。

Linux一直强调的"一切皆文件"哲学概念背后体现出来的是：简单而通用的抽象才能经历时间的考验。















