---
title: 《软件设计的哲学》读后
date: 2025-08-20 10:22:00
tags: [设计,读后]
category: 阅读
---

《软件设计的哲学》一书通篇围绕"复杂性"进行讨论，作者描述各种导致系统复杂度提升的可能性，也提出了一些通用的思想来降低复杂性。

作者将复杂性表现分成三种：变更放大，对于软件开发人员来说，如果需要更改多处才能完成一个需求，那么它就是复杂的；认知复杂，如果需要掌握大量的知识才能完成一项任务，当缺少其中部分知识的认知而来带风险，那么就是复杂的;未知复杂：开发人员必须知晓某些信息才能去完成需求，那么这种复杂性是最糟糕的，因为很有可能开发人员连预防风险的认知都没有。

这三种复杂性的表现几乎随处可见，更改一个需求时需要更改多个类，文件？是否要花很长时间阅读旧代码？是否完全理解该任务所涉及的知识点？更改需求时是否要了解该需求的相关性？对于影响范围有个大概预估？

复杂性不是突然出现的，它更像是一个堆砌的过程，本文将会对该书的部分内容进行综合和讨论，将更多的注意力放在技术的范畴，而忽略其工程治理的部分。



### 如何降低复杂性？

有两种方式可以降低复杂性：1.通过使代码更简单，更显而易见来降低复杂性。2.将复杂性封装起来，也就是通过模块化设计来隐藏细节。

使代码更简单好像是所有[黑客]的追求，各类技术书籍一直强调简单意味着美，优雅来源于简约。在算法领域，用较少的元素完成大量的工作一直被认为是优雅的。现实世界中则存在更复杂的争论，如果一个算法以极少的代码行数实现，但是其他开发人员无法理解。那么这算是简单还是复杂？

用行数来衡量简单和复杂是不准确的，大量浅显且重复的函数散落在系统各处，这不会降低复杂性，只会提高复杂性。不同的编程语言实现同一需求所产生的代码行数也是不一样的，比如Go语言中大量的 `if err != nil`判断，这些重复代码几乎占据函数的一半。但是它简单易懂，不会对开发人员的认知产生挑战。

单一的维度是无法估量复杂性的，书中描述了一个方式来进行估算：**系统的总体复杂度由每个部分的复杂度乘以开发人员在该部分花费的时间加权**。这段话看起来既拗口又难以理解，但是可以通过一个理想的状态来反推它的定义：

> 我们希望一个系统是显而易见的，开发人员可以不用费力思考就可以明白要做什么，同时确信他所做的是正确的。

一个显而易见降低复杂性的小技巧就是：不要使用特例来构建正常的业务需求。这种特例通常使用某个变量硬编码在代码中，使用`if`切成不同的逻辑分支。这样虽然能简单快速实现需求，也不会增加开发人员的的认知负担，但是它极容易泛滥，如果没有一个统一的标识符来描述它的一致性，那么很有可能相同的变量充斥多个模块，这样在后续的版本迭代中需要更改多个地方才能继续拓展。

复杂性由依赖性和模糊性组成。依赖性是软件组成的基础，不可能完全消除它，但是软件设计的目标之一就是减少依赖关系的数量，尽可能使依赖关系保持简单明了。

回到简单，另外一个例子就是变量名，如果一个变量名太过于"晦涩"或者说它过于"通用"，以至于`count`这样的变量名随处可见。模糊性会随着时间的推移进一步提高复杂性，当然另一类开发人员会秉持着"变量名越短越好"的观念。你可以在各个社群中看到各种抱怨，简短的变量名缺乏关键信息，过长的变量名显得臃肿难以记忆，这些观点互相碰撞。本人认为这两者只是风格问题，当你意识到臃肿就应该思考一个新的变量名来简化它，意识到无法通过几个简单字母就能准确表述其中的意义，那么就应该考虑更多的单词来形容它。理想的状态下它们随着版本迭代最终会趋于一个[中庸]的状态，实在无法形容其复杂性，那么至少能为其加上注释;至少要在同一个系统内保持风格的统一;

最糟糕的状况是什么都不做，随着这些复杂性和模糊性不断堆叠，当然这又涉及到架构治理的概念，也就不在本文的讨论范围内。





### 模块化应该如何设计？

最理想的情况下每一个模块都独立于其他模块，开发者可以在模块内独立工作，而对模块一无所知。良好设计的模块将所有改动仅限于该模块内，在架构设计中已经划分好优秀的边界，那么基于这样理想状态下，系统的复杂程度就是设计得最差的模块的复杂度。它不再是一个复杂的数学公式，而是一个"木桶短板理论"。

更普遍的情况则是模块与模块互相依赖，互相调用，当开发者更改其中一个模块，那么也需要更改上下游的其他模块。更糟糕的情况是更改了某个函数的入参，则不可避免更改整个链路。微服务中的复杂程度之所以承几何倍数增长，在于数个服务共同完成同一个功能模块，当其中一个服务发生改变时整个请求链路都会受到影响。

当然对于系统中的独立模块来说还不至于这么复杂，为了进一步降低复杂性模块一般会分成两个部分：接口和实现。接口只描述模块对外提供的功能，而不描述具体细节。实现则执行接口所承诺的目标。这样开发者无需深入了解模块是如何实现的，他只需知晓应该如何调用，以及返回值的意义(更好的情况下还会有注释便于理解)。

模块化编程中，每个模块都会以接口的形式提供[抽象]这一概念，抽象











