## 操作系统基础

1.在 4G 内存的机器上，申请 8G 内存会怎么样？

> 32位操作系统中，在申请虚拟内存阶段就会失败。
>
> 64位操作系统中，进程可以申请8GB内存，但是不能读写它。只要不读写虚拟内存，操作系统就不会分配物理内存。
>
> 操作系统中还需要看overcommit_memory 设置的参数值：
>
> 1.如果值为0 （默认），如果Linux 内核认为申请的内存太大了会被认为不合理，会直接返回错误。
>
> 2.如果值为1，不拒绝任何申请
>
> 3.如果值为2，禁止申请
>
> 还要看有没有开启Swap机制，当申请物理内存超过了空闲物理内存大小时，如果没有开启Swap，程序会直接 OOM；如果开启了Swap则程序可以正常运行。
>
> 答案参考：https://cloud.tencent.cn/developer/article/2221616?from=15425





## Go语言基础

1.下列代码能运行吗？

```go
type Param map[string]interface{}

type Show struct {
	Param
}

func main1() {
	s := new(Show)
	s.Param["RMB"] = 10000
}
```

> 不能，Go 语言中map需要使用make关键词进行初始化
>
> Main函数不能添加数字





2.C1 C2 C3 各自输出什么？为什么？

```go
const (
	C1 int = 1 << iota
	C2
	C3
)
```

> C1 = 1 C2=2 C3 =4
> `iota` 在每个`const`关键字出现时被重置为0，然后在每个后续的常量声明中递增1。
>
> - `C1` 被赋值为 `1 << iota`，由于`iota`在`const`块中被重置为0，所以`C1`的值是 `1 << 0`，即1。
> - `C2` 紧接着`C1`，所以`iota`的值现在是1，因此`C2`的值是 `1 << 1`，即2。
> - `C3` 紧接着`C2`，所以`iota`的值现在是2，因此`C3`的值是 `1 << 2`，即4。



3.Go语言中的内存是如何管理的？



4.Go如何排查内存溢出？



5.Go语言中函数为什么能返回多个参数？



6.new 和 make 的区别



7.map使用时的注意事项



8.Go语言中如何限制并发数量？



## 数据库

1.Mysql 如何优化慢查询









## Docker/Kuberntes 基础

1.Kubernetes 中 Pod的创建过程

> 



2.Kubernetes 中 Request 和 Limit 的区别

> 



3.假设有一个20G内存的宿主机，现在想创建 Request 2G 内存的 Pod，能创建多少个？为什么？

> 



## 网络

1.TCP三次握手和四次挥手



## 项目相关

1.Outh2



## 设计模式

1.简述工厂和单例模式



2.







