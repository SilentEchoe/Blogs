---
title: 架构设计入门
date: 2025-03-11 11:16:00
tags: [架构,设计,读后]
category: 设计
---

架构工程师需要掌握三种能力：理需求的能力；读代码的能力；抽象系统的能力。

架构图虽然需要设计，但是它不是最重要的，最重要的是团队共识的行程与确认的过程。共识是需要精确，无歧义的，而架构图并不精确。精确描述架构的方法是定义每个模块的接口。接口可以用代表直接表达，这种表达是精确且无歧义的。架构图则是辅助模块接口，用于说明模块接口之间的关联。

为了证明接口的有效性，架构工程师应该以伪代码或流程图的方式，过完所有需求，以确认模块之间的接口可以串联起来并良好运转。

框架很重要，但是不要让框架反客为主，溢出模块边界。在系统迭代的过程中，框架会经受变化，以适应需求的演进过程。

比架构图和框架更重要的是数据结构，比数据结构更重要的是接口。



软件架构师的职责，并不是仅仅对软件系统进行边界划分和模块规格的定义。从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布，敏捷地响应需求变更，防范软件质量风险(避免发生软件质量事故)，降低迭代维护成本。

> 架构师虽然是一个技术岗，但是架构师干的事情并不是纯技术方面的。

如何提升需求分析能力，尤其是需求演进的预判能力？它无关技术，主要是心态，除了反复推敲的严谨态度外，对用户反馈的尊重之心也至关重要。

产品边界确立不是一个纯需求，也不是一个纯技术，而是两者合而为一的过程，因为产品功能的开放性设计不是一个纯粹的需求问题，它涉及技术方案的实现探讨。





从逻辑上来看，无论多么复杂的自定义函数，都可以通过：

内置函数，比如证书或小数运算(加减乘除，sin/cos等)；

循环和条件分支；

子函数(自定义函数)；

这样对于任意一个具体的计算(自定义函数)来说，都可以用一组指令序列来表达。

> 不管什么样子的交互设备，要做的首要是定义号统一的数据交换协议，这个数据交换机制和网络上两台电脑通过互联网，需要通过某种数据交换协议进行通信，没有实质性的差别。



架构的第一步是需求分析。从需求分析角度来说，关键是要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点；需求的变化点，则需要相应去做开放性设计。



过程式编程中最核心的两个概念是结构体(自定义的类型)和过程(也叫函数)。通过结构体对数据进行组合，可以构建出任意复杂的自定义数据结构。通过过程可以抽象出任意复杂的自定义指令，复用以前的成果，简化意图的表达。



函数式本质上是过程式的一种约束，它最核心的主张就是变量不可变，函数尽可能没有副作用(对于通用语言来说，所有函数都没有副作用是不可能的，内部有IO行为的函数就有副作用)。



在过程式编程中，数组是一个最常规的数据结构，但是在函数式中因为变量不可变，对某个下表的数组元素的修改就需要复制整个数组(因为数组作为一个变量它不可变)，非常低效。

所以在函数式编程中需要通过一种复杂的平衡二叉树来实现一个使用洁面(接口)上和过程式语言数组一致的“数组”。



面向对象在过程式的基础上，引入了对象(类)和对象方法(类成员函数)，它主张尽可能把方法(其实就是过程)归纳到合适的对象(类)上，不主张全局函数(过程)。

面向对象的核心思想是引入契约，基于对象这样一个概念对代码的使用洁面进行抽象和封装。它因为清晰的使用界面，某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。

面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节。因为这么做破坏类信息的封装，降低类类的可复用性，如果有一天对象的内部实现方式改变了，依赖该对象的相关代码也需要跟着调整。

接口：面向对象至关重要的概念，通过接口，可以优雅实现过程式编程中很费劲才能做到的能力：多态。





操作系统的核心职能是软件治理，而软件治理的一个很重要的部分就是让多个软件可以共同合理使用计算机的资源，不至于出现争抢的局面。从这点来看，Kubernetes被称为云端上的操作系统不是没有道理的。

内存作为计算最基础的硬件资源，有非常特殊的位置。CPU可以直接访问的存储资源非常少，只有寄存器，内存(RAM)，主板上的ROM。寄存器的访问速度非常非常快，但是数量很少，大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行性能。

主板上的ROM是非易失的只读的存储。所谓非易失，是计算机重新启动后它里面的数据仍会存在。这不像内存(RAM),计算机重新启动后它上面的数据就丢失来。ROM非易失和只读的特点，决定了它非常适合存储计算器的启动程序(BIOS)。



**CPU实模式**

CPU直接通过物理地址访问内存。

1.把操作系统内存管理相关的函数地址，放到一个大家公认的地方(比如0X100000处),每个软件要想申请内存就要到这个地方取得内存管理函数并调用它。

2.把内存管理功能设计为一个中断请求。所谓中断，是CPU响应硬件设备时间的一个机制。当某个输入输出设备发生了一件需要CPU来处理的事情，它就会触发一个中断。内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放了一堆函数地址。在CPU收到中断请求时，它会先停下当前的任务来响应中断请求(到中断向量表找到对应的函数地址并执行它)，完成后再去干原来的工作。

中断机制设计之初本来为响应硬件时间之用，但是CPU也提供来指令允许软件处罚一个中断，这叫做软中断。中断机制远不止函数向量表那么简单，比如中断会有优先级，高优先级中断可以打断低优先级中断，反之则不能。





**CPU保护模式**

CPU通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。

保护模式下，内存访问不再是直接通过物理内存，而是通过虚拟内存。虚拟内存模式下，整个内存空间被分成了很多个连续的内存页。每个内存页的大小都是固定的。

每次CPU访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后CPU再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址。

如果某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，这种情况下CPU会发起一个缺页的中断请求。这个缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就选一个最久没有被访问的内存页进行淘汰。并且在淘汰前会把这个内存页的数据保存起来，因为下次CPU访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据。

在保护模式下，计算机的基础架构体系和操作系统共同在努力做一件事情，就是让每个软件“感觉”自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点。



**进程**

进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。

Unix使用fork(先clone再分支，父子进程做不同的操作)。

为什么进程fork是糟糕的？因为进程是操作系统最基础的隔离单位，最忌讳的是进程之间相互联系，但是fork没有拆开这些联系，fork后子进程会基础父进程的句柄。



**协程**

协程不是操作系统内核提供的，它也会被称为"用户态线程"。这是因为协程在用户态下实现的。



从操作系统内核的主线程来说，内核是独立进程。但是从系统调用的角度来说，操作系统内核更像是一个多线程的程序，每个系统调用是来自某个线程的函数调用。

Poll(Linux) 在需要IO时登记一个IO请求，然后统一在某个线程查询谁的IO先完成，谁先完成就让谁处理。它主要是减少了线程的数量。

协程的目的：

回归到同步IO的编程模式；

降低执行体的空间成本和时间成本。



> 快慢是相对而言的，锁的确会导致代码串行，所以在某段代码并发度非常高的情况下，串行执行的确会导致性能的显著降低。但是相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。
>
> 锁最大的问题在于不容易控制。锁Lock但是忘了释放是灾难性的。
>
> 不要在锁里面执行费时操作。



**共享内存**

共享内存其实是虚拟内存的自然结果，虚拟内存本来就需要在内存页与磁盘文件之间进行数据的保存与恢复。将虚拟内存的内存页和磁盘文件的内容建立映射关系，在虚拟内存管理机制中原本就存在。

只需要让两个进程的内存页关联到同一个文件句柄，即可完成进程间的数据共享。



计算机网络:

![image-20250321163523808](https://raw.githubusercontent.com/SilentEchoe/images/main/image-20250321163523808.png)



架构的第一步是做需求分析，然后是概要设计，也就是做子系统的划分，它包含：

子系统职责范围的定义；

子系统的规格(接口),子系统与子系统之间的边界;

需求分解与组合的过程，系统如何满足需求，需求适用型(变化点)的应对策略。

> 不会发生的事情，考虑了并且为它做足了准备，就是过度设计。



需求分析的目标和最终结果，都是要最终形成清晰的产品定义。产品定义并不是简单的产品需求归类。

1.明确产品中有哪些元素，或者资源，以及这些资源的各类操作方式。如果从技术的视角来理解，就是定义对象和方法。

2.需要对产品如何满足用户需求进行确认。

3.产品定义还需要考虑市场策略，产品如何进入市场，和既有市场格局中的其他主流解决方案的关系是什么样的。

架构即创造。

GO 语言其实是在用户态完全重写了操作系统的进程管理和IO子系统。



服务端的领域特征是大规模的用户请求，以及24小时不间断的服务。这句话是理解服务端体系架构的核心，但某种意义上来说更重要的原则是：

坚决不能丢失用户的数据，即他认为已经完成的业务状态。



什么是乐观锁？常规的锁是先互斥，然后在修改数据。无论是否发生冲突，都会先互斥。但是乐观锁不同，它先计算出所有修改的数据，然后最后一步统一提交修改。提交时进行冲突检查，如果没有冲突，这意味着没有人提交新版本，或新版本的数据并不会产生冲突。如果发生冲突则会放弃本次修改。



### 架构思维

重构不是为了改善用户体验，而是为了改善系统质量。做架构需要对一个需求场景的多条实现路径进行思考和评估。

当架构无法很方便地支持某个需求，这意味着架构存在缺陷。架构的能力指的是什么？是理解需求的能力，读代码的能力，抽象系统的能力。

架构设计的基本准则：

1.简单比复杂好，简单强调的是易实施性，让模块更容易实现。

2.相比框架，要更重视模块。从架构设计的角度来说，模块的规格，也就是模块的接口，比模块的实现机制更重要。

3.保证可测试

4.正交分解:Orthogonal Decomposition 



> 优先考虑组合，而不是继承。本质上是鼓励做乘法，而不是做加法。组合就是乘法，它可以让我们用相互正交，完全没有相关性的模块，组合出我们要的业务场景。继承就是做加法，通过叠加能力把一个模块改造成另外一个模块。



> 软件架构的第二定理：为什么做比如何做更重要。虽然架构师最终还是要知道如何实现方案，但他们必须首先要知道为什么这个选择优于另外一个。



分布式架构中，架构师面对的最困难的任务之一就是理清楚作用于其中各个势力和权衡。



设计应该以可测试性为第一目标。



全局性功能往往容易带来复杂的框架。常规的思路是为这个功能实现一个库，并建立一套使用它的机制，也就是框架，以应用到核心系统中去。还有一种思考方式是：通过抽奖核心系统的接口，让全局性功能反向依赖这些接口来完成。



架构的本质是组合：如何用小业务组装出大业务，组装出越来越复杂的系统。另一个是如何应对变化。

> 软件实体(模块，类，函数等)应该对于功能扩展是开放的，但对于修改是封闭的。

如何实现开闭原则？

设计软件要容易维护且不容易出问题的最好办法，就是多扩展，少修改。

> 1.通过接口或抽象类约束扩展，对扩展进行边界限定；
>
> 2.参数类型，引用对象尽量使用接口或抽象类，而不是实现类；
>
> 3.抽象层尽量保持稳定，一旦确定即不允许修改。



### 接口设计

接口在不同的语义环境下，主要有两个不同的含义：

1.模块的使用界面，比如公开的类或函数的原型。模块的接口英国自然体现业务需求。这里的接口，指的就是模块的使用界面。

2.模块对依赖环境的抽象。接口是模块与模块之间的契约。它鼓励模块与模块的交互基于接口作为契约，而不是依赖于具体实现。



KISS(Keep it Simple,Stupid)简单化。接口要KISS指的是需要它简单自然。

在环境依赖上，遵循"最小依赖原则"，尽可能发现模块中多余的依赖。在接口参数的抽象上，不适合过度，如果某种泛化它不会发生，那就是过度设计。不要一开始就把系统设计的非常复杂，而陷入"过度设计"的深渊。应该让系统足够的简单，而不失扩展性，这其中的平衡完全依赖对业务的理解。

从模块实现的角度，环境依赖有两个选择：

1.直接依赖所基于的组件

2.将所依赖的组件所有引用的方法抽象成一个接口，让模块依赖接口而不是具体的组件

大部分情况下应该选择直接依赖组件，而不必去抽象它。

> 如无必要，勿增实体。

当在需要提供多种选择的时候，比如日志组件，对绝大部分的业务模块，都并不希望绑定日志的选择，把决策权交给使用方。在需要解除一个庞大的外部系统的依赖时。有时候我们并不需要多个选择，而是某个外部依赖过重。

对模块的实现依赖进行接口抽象，本质是对模块进行配置化，增加很多配置选项，这样的配置化需要谨慎，适可而止。



### 架构老化

如果不断给系统添加各种新功能，往往会遇到功能需求的实现方式不在当初框架的设定范围内，于是很多功能代码"逃逸"出框架的范围外。

代码老化的标志，是添加功能越来越难，迭代效率降低，问题却是持续不断，解决了一个问题却又生出新的问题。

不依赖核心的含义是业务不依赖。新功能的绝大部分代码独立于既有业务系统，只有少量桥接的代码是耦合的。

局部优化：

1.重写，局部重写。这和开发一个新的功能没什么区别。(局部重构一定要发生在对代码的业务比较了解的情况下)

2.依赖优化。它关注的重心不是某项功能本身的实现，而是它与系统之间的关系。依赖优化整体上做的是代码的搬运工。
