---
title: 基础平台架构读后
date: 2025-03-11 11:16:00
tags: [架构,设计,读后]
category: 设计
---

从逻辑上来看，无论多么复杂的自定义函数，都可以通过：

内置函数，比如证书或小数运算(加减乘除，sin/cos等)；

循环和条件分支；

子函数(自定义函数)；

这样对于任意一个具体的计算(自定义函数)来说，都可以用一组指令序列来表达。

> 不管什么样子的交互设备，要做的首要是定义号统一的数据交换协议，这个数据交换机制和网络上两台电脑通过互联网，需要通过某种数据交换协议进行通信，没有实质性的差别。



架构的第一步是需求分析。从需求分析角度来说，关键是要抓住需求的稳定点和变化点。需求的稳定点，往往是系统的核心价值点；需求的变化点，则需要相应去做开放性设计。



过程式编程中最核心的两个概念是结构体(自定义的类型)和过程(也叫函数)。通过结构体对数据进行组合，可以构建出任意复杂的自定义数据结构。通过过程可以抽象出任意复杂的自定义指令，复用以前的成果，简化意图的表达。



函数式本质上是过程式的一种约束，它最核心的主张就是变量不可变，函数尽可能没有副作用(对于通用语言来说，所有函数都没有副作用是不可能的，内部有IO行为的函数就有副作用)。



在过程式编程中，数组是一个最常规的数据结构，但是在函数式中因为变量不可变，对某个下表的数组元素的修改就需要复制整个数组(因为数组作为一个变量它不可变)，非常低效。

所以在函数式编程中需要通过一种复杂的平衡二叉树来实现一个使用洁面(接口)上和过程式语言数组一致的“数组”。



面向对象在过程式的基础上，引入了对象(类)和对象方法(类成员函数)，它主张尽可能把方法(其实就是过程)归纳到合适的对象(类)上，不主张全局函数(过程)。

面向对象的核心思想是引入契约，基于对象这样一个概念对代码的使用洁面进行抽象和封装。它因为清晰的使用界面，某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。

面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节。因为这么做破坏类信息的封装，降低类类的可复用性，如果有一天对象的内部实现方式改变了，依赖该对象的相关代码也需要跟着调整。

接口：面向对象至关重要的概念，通过接口，可以优雅实现过程式编程中很费劲才能做到的能力：多态。





操作系统的核心职能是软件治理，而软件治理的一个很重要的部分就是让多个软件可以共同合理使用计算机的资源，不至于出现争抢的局面。从这点来看，Kubernetes被称为云端上的操作系统不是没有道理的。

内存作为计算最基础的硬件资源，有非常特殊的位置。CPU可以直接访问的存储资源非常少，只有寄存器，内存(RAM)，主板上的ROM。寄存器的访问速度非常非常快，但是数量很少，大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行性能。

主板上的ROM是非易失的只读的存储。所谓非易失，是计算机重新启动后它里面的数据仍会存在。这不像内存(RAM),计算机重新启动后它上面的数据就丢失来。ROM非易失和只读的特点，决定了它非常适合存储计算器的启动程序(BIOS)。



**CPU实模式**

CPU直接通过物理地址访问内存。

1.把操作系统内存管理相关的函数地址，放到一个大家公认的地方(比如0X100000处),每个软件要想申请内存就要到这个地方取得内存管理函数并调用它。

2.把内存管理功能设计为一个中断请求。所谓中断，是CPU响应硬件设备时间的一个机制。当某个输入输出设备发生了一件需要CPU来处理的事情，它就会触发一个中断。内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放了一堆函数地址。在CPU收到中断请求时，它会先停下当前的任务来响应中断请求(到中断向量表找到对应的函数地址并执行它)，完成后再去干原来的工作。

中断机制设计之初本来为响应硬件时间之用，但是CPU也提供来指令允许软件处罚一个中断，这叫做软中断。中断机制远不止函数向量表那么简单，比如中断会有优先级，高优先级中断可以打断低优先级中断，反之则不能。





**CPU保护模式**

CPU通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。

保护模式下，内存访问不再是直接通过物理内存，而是通过虚拟内存。虚拟内存模式下，整个内存空间被分成了很多个连续的内存页。每个内存页的大小都是固定的。

每次CPU访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后CPU再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址。

如果某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，这种情况下CPU会发起一个缺页的中断请求。这个缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就选一个最久没有被访问的内存页进行淘汰。并且在淘汰前会把这个内存页的数据保存起来，因为下次CPU访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据。

在保护模式下，计算机的基础架构体系和操作系统共同在努力做一件事情，就是让每个软件“感觉”自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点。



**进程**

进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。

Unix使用fork(先clone再分支，父子进程做不同的操作)。

为什么进程fork是糟糕的？因为进程是操作系统最基础的隔离单位，最忌讳的是进程之间相互联系，但是fork没有拆开这些联系，fork后子进程会基础父进程的句柄。



**协程**

协程不是操作系统内核提供的，它也会被称为"用户态线程"。这是因为协程在用户态下实现的。



从操作系统内核的主线程来说，内核是独立进程。但是从系统调用的角度来说，操作系统内核更像是一个多线程的程序，每个系统调用是来自某个线程的函数调用。

Poll(Linux) 在需要IO时登记一个IO请求，然后统一在某个线程查询谁的IO先完成，谁先完成就让谁处理。它主要是减少了线程的数量。

协程的目的：

回归到同步IO的编程模式；

降低执行体的空间成本和时间成本。



> 快慢是相对而言的，锁的确会导致代码串行，所以在某段代码并发度非常高的情况下，串行执行的确会导致性能的显著降低。但是相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。
>
> 锁最大的问题在于不容易控制。锁Lock但是忘了释放是灾难性的。
>
> 不要在锁里面执行费时操作。



**共享内存**

共享内存其实是虚拟内存的自然结果，虚拟内存本来就需要在内存页与磁盘文件之间进行数据的保存与恢复。将虚拟内存的内存页和磁盘文件的内容建立映射关系，在虚拟内存管理机制中原本就存在。

只需要让两个进程的内存页关联到同一个文件句柄，即可完成进程间的数据共享。
